<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeMirror 6 Editor</title>
    <script type="importmap">
    {
        "imports": {
            "codemirror": "https://esm.sh/codemirror@6.0.1",
            "@codemirror/view": "https://esm.sh/@codemirror/view@6.26.3",
            "@codemirror/commands": "https://esm.sh/@codemirror/commands@6.4.0",
            "@codemirror/state": "https://esm.sh/@codemirror/state@6.4.1",
            "@codemirror/language": "https://esm.sh/@codemirror/language@6.10.1",
            "@codemirror/search": "https://esm.sh/@codemirror/search@6.5.6",
            "@codemirror/lang-html": "https://esm.sh/@codemirror/lang-html@6.4.8",
            "@codemirror/lang-json": "https://esm.sh/@codemirror/lang-json@6.0.1",
            "@codemirror/lang-xml": "https://esm.sh/@codemirror/lang-xml@6.1.0",
            "@codemirror/lang-yaml": "https://esm.sh/@codemirror/lang-yaml@6.1.2",
            "@codemirror/theme-one-dark": "https://esm.sh/@codemirror/theme-one-dark@6.1.2",
            "@codemirror/merge": "https://esm.sh/@codemirror/merge@6",
            "@codemirror/lint": "https://esm.sh/@codemirror/lint@6.8.4",
            "qrcode": "https://esm.sh/qrcode@1.5.3",
            "jsqr": "https://esm.sh/jsqr@1.4.0",
            "jose": "https://esm.sh/jose@5",
            "randexp": "https://esm.sh/randexp@0.5.1",
            "js-yaml": "https://esm.sh/js-yaml@4.1.0"
        }
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: #1e1e1e;
            color: #fff;
            overflow: hidden;
        }

        .toolbar {
            background: #252526;
            padding: 10px 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            border-bottom: 1px solid #3e3e42;
            flex-wrap: wrap;
        }

        .toolbar button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .toolbar button:hover {
            background: #1177bb;
        }

        .toolbar select {
            background: #3c3c3c;
            color: white;
            border: 1px solid #3e3e42;
            padding: 6px 10px;
            border-radius: 3px;
            font-size: 13px;
            cursor: pointer;
        }

        .toolbar input[type="file"] {
            display: none;
        }

        .toolbar label {
            background: #0e639c;
            color: white;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .toolbar label:hover {
            background: #1177bb;
        }

        .toolbar .separator {
            width: 1px;
            height: 24px;
            background: #3e3e42;
            margin: 0 5px;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: #3c3c3c;
            min-width: 180px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            margin-top: 2px;
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-content button {
            display: block;
            width: 100%;
            text-align: left;
            background: transparent;
            color: #cccccc;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            border-radius: 0;
        }

        .dropdown-content button:hover {
            background: #094771;
        }

        .dropdown-content button:first-child {
            border-radius: 3px 3px 0 0;
        }

        .dropdown-content button:last-child {
            border-radius: 0 0 3px 3px;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 250px;
            background: #252526;
            border-right: 1px solid #3e3e42;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar.collapsed {
            width: 0;
            border: none;
        }

        .sidebar-header {
            padding: 10px;
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-header h3 {
            font-size: 13px;
            font-weight: 600;
            color: #cccccc;
        }

        .sidebar-actions {
            display: flex;
            gap: 5px;
        }

        .sidebar-actions button {
            background: transparent;
            border: none;
            color: #cccccc;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 16px;
        }

        .sidebar-actions button:hover {
            background: #3e3e42;
        }

        .file-tree {
            flex: 1;
            overflow-y: auto;
            padding: 5px 0;
        }

        .tree-item {
            padding: 4px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #cccccc;
            user-select: none;
        }

        .tree-item:hover {
            background: #2a2d2e;
        }

        .tree-item.active {
            background: #37373d;
            color: #fff;
        }

        .tree-item.active-secondary {
            background: #2f3236;
            color: #d4d4d4;
            border-left: 3px solid #0e639c;
        }

        .tree-item.folder {
            font-weight: 500;
        }

        .tree-item .icon {
            font-size: 14px;
            width: 16px;
            text-align: center;
        }

        .tree-item .name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }

        .tree-item.dirty .name {
            color: #ffcc00;
        }

        .tree-item .actions {
            display: none;
            gap: 4px;
            margin-left: 8px;
        }

        .tree-item:hover .actions {
            display: flex;
        }

        .tree-item .actions button {
            background: transparent;
            border: none;
            color: #cccccc;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 14px;
            line-height: 1;
        }

        .tree-item .actions button:hover {
            background: #3e3e42;
            color: #fff;
        }

        .tree-item .actions button.confirm {
            color: #c5242d;
        }

        .tree-item .actions button.confirm:hover {
            background: #c5242d;
            color: #fff;
        }

        .tree-item .actions button.cancel {
            color: #cccccc;
        }

        .tree-item .actions button.cancel:hover {
            background: #3e3e42;
            color: #fff;
        }

        .tree-item.indent-1 {
            padding-left: 24px;
        }

        .tree-item.indent-2 {
            padding-left: 40px;
        }

        .tree-item.indent-3 {
            padding-left: 56px;
        }

        /* Drag and drop styles */
        .tree-item.dragging {
            opacity: 0.4;
        }

        .tree-item.drag-over {
            background: #094771 !important;
            border-left: 3px solid #007acc;
        }

        .tree-item[draggable="true"] {
            cursor: grab;
        }

        .tree-item[draggable="true"]:active {
            cursor: grabbing;
        }

        /* Split view styles */
        #editor-container {
            flex: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }

        #editor-container.editor-split {
            overflow: hidden;
        }

        #editor-container.editor-split .editor-content {
            flex: 1;
            display: flex;
            min-height: 0;
        }

        #editor-container.editor-split .editor-pane {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        #editor-container.editor-split .editor-pane + .editor-pane {
            border-left: 1px solid #2b2b2b;
        }

        #editor-container.editor-split .pane-header {
            background: #1f1f1f;
            color: #b8b8b8;
            font-size: 12px;
            padding: 6px 10px;
            border-bottom: 1px solid #2b2b2b;
            display: flex;
            align-items: center;
            min-height: 28px;
        }

        #editor-container.editor-split .pane-title {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #editor-container.editor-split .pane-close {
            margin-left: auto;
            background: transparent;
            border: none;
            color: #b8b8b8;
            cursor: pointer;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 3px;
        }

        #editor-container.editor-split .pane-close:hover {
            background: #3e3e42;
            color: #fff;
        }

        #editor-container.editor-split .pane-header.active {
            background: #2a2f36;
            color: #ffffff;
        }

        #editor-container.editor-split .pane-content {
            flex: 1;
            min-height: 0;
        }

        .editor-header {
            background: #252525;
            color: #cccccc;
            padding: 8px 12px;
            font-size: 13px;
            border-bottom: 1px solid #1e1e1e;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-header .filename {
            font-weight: 500;
        }

        .editor-header .close-btn {
            background: transparent;
            border: none;
            color: #cccccc;
            cursor: pointer;
            font-size: 12px;
        }

        .editor-header .close-btn:hover {
            background: #3e3e42;
            color: #fff;
        }

        .comparison-format-selector {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .comparison-view-selector {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .comparison-view-selector select {
            background: #3c3c3c;
            color: #fff;
            border: 1px solid #3e3e42;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
        }

        .comparison-format-selector input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        .format-label {
            font-size: 12px;
            color: #cccccc;
            font-weight: 500;
        }

        #editor-container:not(.split-view) .editor-header {
            display: none;
        }

        #editor-container:not(.split-view) .editor-content {
            flex-grow: 1;
        }

        /* Diff highlighting styles */
        .cm-deletedChunk {
            background-color: rgba(248, 81, 73, 0.15) !important;
            border-left: 3px solid rgba(248, 81, 73, 0.6);
        }

        .cm-insertedChunk {
            background-color: rgba(87, 171, 90, 0.15) !important;
            border-left: 3px solid rgba(87, 171, 90, 0.6);
        }

        .cm-deletedText {
            background-color: rgba(248, 81, 73, 0.25) !important;
            text-decoration: line-through;
        }

        .cm-insertedText {
            background-color: rgba(87, 171, 90, 0.25) !important;
        }

        .cm-changedLine {
            background-color: rgba(255, 255, 0, 0.08) !important;
        }

        /* MergeView container styling */
        .cm-mergeView {
            display: flex;
            height: 100%;
            width: 100%;
            overflow: hidden;
        }

        .cm-mergeViewEditors {
            width: 100%;
        }

        .cm-mergeViewEditor {
            flex: 1;
            overflow: auto;
        }

        .cm-merge-revert {
            display: none; /* Hide revert buttons since this is read-only comparison */
        }

        .cm-chunkButtons {
            display: none;
        }

        .cm-editor {
            height: 100%;
        }

        .cm-scroller {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
        }

        /* Lint error styling */
        .cm-lintRange-error {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='6' height='3'%3E%3Cpath d='M0 3 L3 0 L6 3' fill='none' stroke='%23f85149' stroke-width='0.6'/%3E%3C/svg%3E");
            background-repeat: repeat-x;
            background-position: bottom left;
            padding-bottom: 2px;
        }

        .cm-lintRange-warning {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='6' height='3'%3E%3Cpath d='M0 3 L3 0 L6 3' fill='none' stroke='%23d29922' stroke-width='0.6'/%3E%3C/svg%3E");
            background-repeat: repeat-x;
            background-position: bottom left;
            padding-bottom: 2px;
        }

        .cm-tooltip-lint {
            background: #2d2d2d;
            border: 1px solid #f85149;
            color: #f85149;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 3px;
        }

        .cm-diagnostic-error {
            border-left: 3px solid #f85149;
            padding-left: 4px;
        }

        .cm-lintPoint-error:after {
            border-bottom-color: #f85149;
        }

        .status-bar {
            background: #007acc;
            color: white;
            padding: 4px 15px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: #252526;
            padding: 20px;
            border: 1px solid #3e3e42;
            border-radius: 6px;
            min-width: 400px;
            max-width: 500px;
        }

        .modal-header {
            margin-bottom: 15px;
        }

        .modal-header h2 {
            font-size: 16px;
            color: #fff;
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-body label {
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
            color: #cccccc;
        }

        .modal-body input {
            padding: 8px;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            border-radius: 3px;
            color: #fff;
            font-size: 13px;
        }

        .modal-body input:focus {
            outline: none;
            border-color: #007acc;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-footer button {
            padding: 6px 16px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
        }

        .modal-footer .btn-primary {
            background: #0e639c;
            color: white;
        }

        .modal-footer .btn-primary:hover {
            background: #1177bb;
        }

        .modal-footer .btn-secondary {
            background: #3c3c3c;
            color: white;
        }

        .modal-footer .btn-secondary:hover {
            background: #4c4c4c;
        }

        .modal-footer .btn-danger {
            background: #c5242d;
            color: white;
        }

        .modal-footer .btn-danger:hover {
            background: #e81224;
        }
    </style>
</head>

<body>
    <div class="toolbar">
        <button id="toggle-sidebar-btn">‚ò∞</button>

        <label for="file-upload">Import File</label>
        <input type="file" id="file-upload" />

        <div class="separator"></div>

        <div class="dropdown">
            <button id="format-btn">Format ‚ñæ</button>
            <div class="dropdown-content" id="format-menu">
                <button id="format-code">Format Code</button>
                <button id="minify-code">Minify Code</button>
            </div>
        </div>

        <div class="dropdown">
            <button id="convert-case-btn">Convert Case ‚ñæ</button>
            <div class="dropdown-content" id="convert-case-menu">
                <button id="convert-pascal">PascalCase</button>
                <button id="convert-camel">camelCase</button>
                <button id="convert-snake">snake_case</button>
                <button id="convert-kebab">kebab-case</button>
                <button id="convert-upper">UPPERCASE</button>
                <button id="convert-lower">lowercase</button>
            </div>
        </div>

        <div class="dropdown">
            <button id="escape-unescape-btn">Escape/Unescape ‚ñæ</button>
            <div class="dropdown-content" id="escape-unescape-menu">
                <button id="escape-json">Escape JSON</button>
                <button id="unescape-json">Unescape JSON</button>
                <button id="escape-html">Escape HTML</button>
                <button id="unescape-html">Unescape HTML</button>
                <button id="encode-full-url">Encode URL</button>
                <button id="decode-full-url">Decode URL</button>
                <button id="encode-url">Encode URL Component</button>
                <button id="decode-url">Decode URL Component</button>
            </div>
        </div>

        <div class="dropdown">
            <button id="base64-btn">Base64 ‚ñæ</button>
            <div class="dropdown-content" id="base64-menu">
                <button id="encode-base64">Encode Base64</button>
                <button id="decode-base64">Decode Base64 (Preview)</button>
            </div>
        </div>

        <div class="dropdown">
            <button id="qrcode-btn">QR Code ‚ñæ</button>
            <div class="dropdown-content" id="qrcode-menu">
                <button id="generate-qrcode">Generate QR Code</button>
                <button id="read-qrcode">Read QR Code</button>
            </div>
        </div>

        <div class="dropdown">
            <button id="jwt-btn">JWT ‚ñæ</button>
            <div class="dropdown-content" id="jwt-menu">
                <button id="jwt-sign">Sign JWT</button>
                <button id="jwt-verify">Verify JWT</button>
                <button id="jwt-decode">Decode JWT (no verify)</button>
                <button id="jwt-settings">Settings</button>
            </div>
        </div>

        <div class="dropdown">
            <button id="jwe-btn">JWE ‚ñæ</button>
            <div class="dropdown-content" id="jwe-menu">
                <button id="jwe-encrypt">Encrypt JWE</button>
                <button id="jwe-decrypt">Decrypt JWE</button>
                <button id="jwe-settings">Settings</button>
            </div>
        </div>

        <div class="dropdown">
            <button id="generator-btn">Generator ‚ñæ</button>
            <div class="dropdown-content" id="generator-menu">
                <button id="generate-timestamp">Current Timestamp...</button>
                <button id="generate-uuid">UUID v4</button>
                <button id="generate-random-string">Random String...</button>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h3>FILES</h3>
                <div class="sidebar-actions">
                    <button id="new-file-sidebar-btn" title="New File">üìÑ</button>
                    <button id="new-folder-btn" title="New Folder">üìÅ</button>
                </div>
            </div>
            <div class="file-tree" id="file-tree"></div>
        </div>

        <div id="editor-container">
            <div class="editor-header">
                    <span class="filename" id="filename-main"></span>
                    <span class="filename" id="filename-compare"></span>
                    <div class="comparison-format-selector" id="format-toggle-container" style="display: none;">
                        <label class="format-label">
                            <input type="checkbox" id="comparison-format-toggle" />
                            <span id="comparison-format-text">Format view</span>
                        </label>
                    </div>
                    <div class="comparison-view-selector" id="view-mode-container" style="display: none;">
                        <label class="format-label" for="comparison-view-mode">View</label>
                        <select id="comparison-view-mode">
                            <option value="side-by-side">Side-by-side</option>
                            <option value="inline">Inline</option>
                        </select>
                    </div>
                    <button class="close-btn" id="close-comparison-btn" title="Close Comparison">‚úï</button>
                </div>
                <div id="editor-content" class="editor-content"></div>
        </div>
    </div>

    <div class="status-bar">
        <span id="status-info">Ready</span>
        <span id="cursor-info">Ln 1, Col 1</span>
    </div>

    <!-- Rename/Create Modal -->
    <div class="modal" id="rename-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">Rename</h2>
            </div>
            <div class="modal-body">
                <label id="modal-label">Name:</label>
                <input type="text" id="modal-input" style="width: 100%;" />
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="modal-cancel">Cancel</button>
                <button class="btn-primary" id="modal-confirm">OK</button>
            </div>
        </div>
    </div>

    <!-- JWT Settings Modal -->
    <div class="modal" id="jwt-settings-modal">
        <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h2>JWT Settings</h2>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">Algorithm:</label>
                    <select id="jwt-algorithm" style="width: 100%; padding: 8px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px;">
                        <option value="HS256">HS256 (HMAC + SHA-256)</option>
                        <option value="HS384">HS384 (HMAC + SHA-384)</option>
                        <option value="HS512">HS512 (HMAC + SHA-512)</option>
                        <option value="RS256">RS256 (RSA + SHA-256)</option>
                        <option value="RS384">RS384 (RSA + SHA-384)</option>
                        <option value="RS512">RS512 (RSA + SHA-512)</option>
                        <option value="ES256">ES256 (ECDSA + SHA-256)</option>
                        <option value="ES384">ES384 (ECDSA + SHA-384)</option>
                        <option value="ES512">ES512 (ECDSA + SHA-512)</option>
                    </select>
                </div>

                <div id="jwt-secret-key-section" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">JWT Secret Key (minimum 32 chars for HS256):</label>
                    <input type="text" id="jwt-secret-key" style="width: 100%; padding: 8px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px; font-family: monospace;" placeholder="Enter secret key..." />
                    <small style="color: #888; display: block; margin-top: 5px;">HS256: 32+ chars, HS384: 48+ chars, HS512: 64+ chars</small>
                </div>

                <div id="jwt-keypair-section" style="margin-bottom: 15px; display: none;">
                    <div style="margin-bottom: 10px;">
                        <button id="jwt-generate-keypair-btn" style="padding: 8px 16px; background: #0e639c; color: white; border: none; border-radius: 3px; cursor: pointer;">Generate Key Pair</button>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px;">Public Key (PEM SPKI) - Paste or Generate:</label>
                        <textarea id="jwt-public-key" style="width: 100%; height: 120px; padding: 8px; background: #2d2d2d; color: #d4d4d4; border: 1px solid #3e3e42; border-radius: 3px; font-family: monospace; font-size: 11px; resize: vertical;" placeholder="-----BEGIN PUBLIC KEY-----&#10;...&#10;-----END PUBLIC KEY-----"></textarea>
                        <div style="display: flex; gap: 5px; margin-top: 5px;">
                            <button id="jwt-copy-public-key-btn" style="padding: 4px 12px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px; cursor: pointer; font-size: 12px;">Copy</button>
                            <button id="jwt-clear-public-key-btn" style="padding: 4px 12px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px;">Private Key (PEM PKCS8) - Paste or Generate:</label>
                        <textarea id="jwt-private-key" style="width: 100%; height: 120px; padding: 8px; background: #2d2d2d; color: #d4d4d4; border: 1px solid #3e3e42; border-radius: 3px; font-family: monospace; font-size: 11px; resize: vertical;" placeholder="-----BEGIN PRIVATE KEY-----&#10;...&#10;-----END PRIVATE KEY-----"></textarea>
                        <div style="display: flex; gap: 5px; margin-top: 5px;">
                            <button id="jwt-copy-private-key-btn" style="padding: 4px 12px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px; cursor: pointer; font-size: 12px;">Copy</button>
                            <button id="jwt-clear-private-key-btn" style="padding: 4px 12px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px; cursor: pointer; font-size: 12px;">Clear</button>
                        </div>
                    </div>
                </div>

                <div style="margin-bottom: 15px; padding-top: 15px; border-top: 1px solid #3e3e42;">
                    <label style="display: flex; align-items: center; margin-bottom: 10px;">
                        <input type="checkbox" id="jwt-auto-iat" style="margin-right: 8px;" checked />
                        <span>Auto IAT (Issued At) - Set iat to current time</span>
                    </label>

                    <label style="display: flex; align-items: center; margin-bottom: 10px;">
                        <input type="checkbox" id="jwt-auto-exp" style="margin-right: 8px;" />
                        <span>Auto Exp (Expires At) - Set relative to IAT</span>
                    </label>

                    <div id="exp-config-section" style="display: none;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="jwt-exp-duration" min="1" value="1" style="width: 100px; padding: 8px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px;" />
                            <select id="jwt-exp-unit" style="flex: 1; padding: 8px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px;">
                                <option value="seconds">Seconds</option>
                                <option value="minutes">Minutes</option>
                                <option value="hours" selected>Hours</option>
                                <option value="days">Days</option>
                                <option value="months">Months</option>
                                <option value="years">Years</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="jwt-settings-cancel">Cancel</button>
                <button class="btn-primary" id="jwt-settings-save">Save</button>
            </div>
        </div>
    </div>

    <!-- JWE Settings Modal -->
    <div class="modal" id="jwe-settings-modal">
        <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h2>JWE Settings</h2>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">JWE Algorithm:</label>
                    <select id="jwe-algorithm" style="width: 100%; padding: 8px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px;">
                        <option value="dir">dir (A256GCM, shared secret)</option>
                        <option value="ECDH-ES">ECDH-ES (A256GCM, EC key agreement)</option>
                    </select>
                    <small style="color: #888; display: block; margin-top: 5px;">Choose between shared secret or EC key agreement for JWE.</small>
                </div>

                <div id="jwe-secret-key-section" style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px;">JWE Secret Key (minimum 32 chars for AES-256):</label>
                    <input type="text" id="jwe-secret-key" style="width: 100%; padding: 8px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px; font-family: monospace;" placeholder="Enter secret key for JWE encryption..." />
                    <small style="color: #888; display: block; margin-top: 5px;">Required: 32+ characters for AES-256 GCM encryption</small>
                </div>

                <div id="jwe-keypair-section" style="margin-bottom: 15px; display: none;">
                    <label style="display: block; margin-bottom: 5px;">JWE Public Key (PEM):</label>
                    <textarea id="jwe-public-key" style="width: 100%; height: 100px; padding: 8px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px; font-family: monospace;" placeholder="Paste recipient public key (PEM) for ECDH-ES..."></textarea>
                    <label style="display: block; margin: 10px 0 5px;">JWE Private Key (PEM):</label>
                    <textarea id="jwe-private-key" style="width: 100%; height: 120px; padding: 8px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px; font-family: monospace;" placeholder="Paste private key (PEM) for decryption..."></textarea>
                    <div style="display: flex; gap: 5px; margin-top: 8px;">
                        <button id="jwe-generate-keypair-btn" style="padding: 4px 12px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px; cursor: pointer; font-size: 12px;">Generate Key Pair</button>
                    </div>
                    <small style="color: #888; display: block; margin-top: 5px;">Use matching EC keys (e.g., P-256) for ECDH-ES with A256GCM.</small>
                </div>

                <div style="margin-bottom: 15px; padding-top: 15px; border-top: 1px solid #3e3e42;">
                    <label style="display: flex; align-items: center; margin-bottom: 10px;">
                        <input type="checkbox" id="jwe-auto-iat" style="margin-right: 8px;" checked />
                        <span>Auto IAT (Issued At) - Set iat to current time</span>
                    </label>

                    <label style="display: flex; align-items: center; margin-bottom: 10px;">
                        <input type="checkbox" id="jwe-auto-exp" style="margin-right: 8px;" />
                        <span>Auto Exp (Expires At) - Set relative to IAT</span>
                    </label>

                    <div id="jwe-exp-config-section" style="display: none;">
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="number" id="jwe-exp-duration" min="1" value="1" style="width: 100px; padding: 8px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px;" />
                            <select id="jwe-exp-unit" style="flex: 1; padding: 8px; background: #3c3c3c; color: white; border: 1px solid #3e3e42; border-radius: 3px;">
                                <option value="seconds">Seconds</option>
                                <option value="minutes">Minutes</option>
                                <option value="hours" selected>Hours</option>
                                <option value="days">Days</option>
                                <option value="months">Months</option>
                                <option value="years">Years</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="jwe-settings-cancel">Cancel</button>
                <button class="btn-primary" id="jwe-settings-save">Save</button>
            </div>
        </div>
    </div>

    <!-- Generator Settings Modal -->
    <div id="generator-settings-modal" class="modal">
        <div class="modal-content">
            <h2>Generator Settings</h2>
            <div class="modal-body">
                <div class="form-section">
                    <h3>Timestamp Format</h3>
                    <div class="form-group">
                        <label>
                            <input type="radio" name="timestamp-format" value="unix_ms" checked>
                            Unix Milliseconds (e.g., 1731599123456)
                        </label>
                        <label>
                            <input type="radio" name="timestamp-format" value="unix_s">
                            Unix Seconds (e.g., 1731599123)
                        </label>
                        <label>
                            <input type="radio" name="timestamp-format" value="iso8601">
                            ISO 8601 (e.g., 2025-11-14T10:32:03.456Z)
                        </label>
                    </div>
                </div>

                <div class="form-section">
                    <h3>Random String</h3>
                    <div class="form-group">
                        <label for="regex-preset">Pattern Type:</label>
                        <select id="regex-preset">
                            <option value="alpha">Letters only</option>
                            <option value="numeric">Numbers only</option>
                            <option value="alphanumeric" selected>Letters + Numbers</option>
                            <option value="special">Letters + Numbers + Special chars</option>
                            <option value="custom">Custom Regex...</option>
                        </select>
                    </div>

                    <div id="custom-regex-section" style="display: none;">
                        <div class="form-group">
                            <label for="custom-regex-name">Custom Regex Name:</label>
                            <input type="text" id="custom-regex-name" placeholder="e.g., Phone Number">
                        </div>
                        <div class="form-group">
                            <label for="custom-regex-pattern">Custom Regex Pattern:</label>
                            <input type="text" id="custom-regex-pattern" placeholder="e.g., [0-9]{3}-[0-9]{3}-[0-9]{4}">
                        </div>
                        <div class="form-group">
                            <button type="button" id="delete-custom-regex-btn" class="btn-secondary" style="display: none;">Delete Custom Regex</button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="random-length">Length:</label>
                        <input type="number" id="random-length" value="16" min="1" max="1000">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="generator-settings-cancel">Cancel</button>
                <button class="btn-primary" id="generator-settings-generate">Generate</button>
            </div>
        </div>
    </div>

    <!-- Format Type Selection Modal -->
    <div class="modal" id="format-type-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Select Format Type</h2>
            </div>
            <div class="modal-body">
                <p>This file has no extension or is a text file. Please select the format type:</p>
                <div class="form-group">
                    <label><input type="radio" name="format-type" value="json" checked> JSON</label>
                </div>
                <div class="form-group">
                    <label><input type="radio" name="format-type" value="html"> HTML</label>
                </div>
                <div class="form-group">
                    <label><input type="radio" name="format-type" value="xml"> XML</label>
                </div>
                <div class="form-group">
                    <label><input type="radio" name="format-type" value="yaml"> YAML</label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="format-type-cancel">Cancel</button>
                <button class="btn-primary" id="format-type-ok">OK</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { EditorView, basicSetup } from 'codemirror';
        import { keymap } from '@codemirror/view';
        import { indentWithTab, indentMore, indentLess } from '@codemirror/commands';
        import { Transaction, EditorSelection } from '@codemirror/state';
        import { html } from '@codemirror/lang-html';
        import { json } from '@codemirror/lang-json';
        import { xml } from '@codemirror/lang-xml';
        import { yaml } from '@codemirror/lang-yaml';
        import { oneDark } from '@codemirror/theme-one-dark';
        import { search, highlightSelectionMatches } from '@codemirror/search';
        import { MergeView, unifiedMergeView } from '@codemirror/merge';
        import { linter, lintGutter } from '@codemirror/lint';
        import * as jsYaml from 'js-yaml';
        import QRCode from 'qrcode';
        import jsQR from 'jsqr';
        import * as jose from 'jose';
        import { exportSPKI, exportPKCS8, importSPKI, importPKCS8 } from 'jose';
        import RandExp from 'randexp';

        // ===== IndexedDB Setup =====
        const DB_NAME = 'CodeEditorDB';
        const DB_VERSION = 1;
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    if (!db.objectStoreNames.contains('files')) {
                        const fileStore = db.createObjectStore('files', { keyPath: 'id', autoIncrement: true });
                        fileStore.createIndex('path', 'path', { unique: true });
                        fileStore.createIndex('parentId', 'parentId', { unique: false });
                    }

                    if (!db.objectStoreNames.contains('jwtSettings')) {
                        db.createObjectStore('jwtSettings', { keyPath: 'id' });
                    }

                    if (!db.objectStoreNames.contains('jweSettings')) {
                        db.createObjectStore('jweSettings', { keyPath: 'id' });
                    }

                    if (!db.objectStoreNames.contains('generatorSettings')) {
                        db.createObjectStore('generatorSettings', { keyPath: 'id' });
                    }

                    if (!db.objectStoreNames.contains('formatSettings')) {
                        db.createObjectStore('formatSettings', { keyPath: 'id' });
                    }

                    if (!db.objectStoreNames.contains('appSettings')) {
                        db.createObjectStore('appSettings', { keyPath: 'id' });
                    }

                };
            });
        }

        // CRUD Operations
        async function createFile(name, content = '', parentId = null) {
            const path = parentId ? `${await getItemPath(parentId)}/${name}` : name;
            const transaction = db.transaction(['files'], 'readwrite');
            const store = transaction.objectStore('files');

            const file = {
                name,
                path,
                content,
                type: 'file',
                parentId,
                createdAt: new Date(),
                updatedAt: new Date()
            };

            return new Promise((resolve, reject) => {
                const request = store.add(file);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function createFolder(name, parentId = null) {
            const path = parentId ? `${await getItemPath(parentId)}/${name}` : name;
            const transaction = db.transaction(['files'], 'readwrite');
            const store = transaction.objectStore('files');

            const folder = {
                name,
                path,
                type: 'folder',
                parentId,
                createdAt: new Date(),
                updatedAt: new Date()
            };

            return new Promise((resolve, reject) => {
                const request = store.add(folder);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function getItem(id) {
            // Check if it's a temporary file (negative ID)
            if (id < 0) {
                return tempFiles.get(id) || null;
            }

            const transaction = db.transaction(['files'], 'readonly');
            const store = transaction.objectStore('files');

            return new Promise((resolve, reject) => {
                const request = store.get(id);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function getItemPath(id) {
            const item = await getItem(id);
            return item ? item.path : '';
        }

        async function getAllItems() {
            const transaction = db.transaction(['files'], 'readonly');
            const store = transaction.objectStore('files');

            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => {
                    const dbItems = request.result;
                    // Add temporary files to the list
                    const tempItems = Array.from(tempFiles.entries()).map(([id, data]) => ({
                        id,
                        ...data
                    }));
                    resolve([...dbItems, ...tempItems]);
                };
                request.onerror = () => reject(request.error);
            });
        }

        async function updateFile(id, updates) {
            // Get the item BEFORE starting the transaction
            const item = await getItem(id);

            if (!item) return;

            const updated = {
                ...item,
                ...updates,
                updatedAt: new Date()
            };

            // Handle temporary files
            if (id < 0) {
                tempFiles.set(id, updated);
                return id;
            }

            // Now start the transaction for the update
            const transaction = db.transaction(['files'], 'readwrite');
            const store = transaction.objectStore('files');

            return new Promise((resolve, reject) => {
                const request = store.put(updated);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function deleteItem(id) {
            // Handle temporary files
            if (id < 0) {
                tempFiles.delete(id);
                fileDirtyState.delete(id);
                draftContent.delete(id);
                return Promise.resolve();
            }

            // Get all children recursively BEFORE starting the transaction
            const items = await getAllItems();
            const toDelete = [id];
            const findChildren = (parentId) => {
                items.forEach(item => {
                    if (item.parentId === parentId) {
                        toDelete.push(item.id);
                        if (item.type === 'folder') {
                            findChildren(item.id);
                        }
                        // Clean up temporary file tracking for any temp files
                        if (item.id < 0) {
                            tempFiles.delete(item.id);
                            fileDirtyState.delete(item.id);
                            draftContent.delete(item.id);
                        }
                    }
                });
            };
            findChildren(id);

            // Now start the transaction and delete all items from IndexedDB (skip temp files)
            const transaction = db.transaction(['files'], 'readwrite');
            const store = transaction.objectStore('files');
            return Promise.all(toDelete.filter(itemId => itemId >= 0).map(itemId => {
                return new Promise((resolve, reject) => {
                    const request = store.delete(itemId);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }));
        }

        async function renameItem(id, newName) {
            const item = await getItem(id);
            if (!item) return;

            const newPath = item.parentId
                ? `${await getItemPath(item.parentId)}/${newName}`
                : newName;

            await updateFile(id, { name: newName, path: newPath });

            // Update all children paths if folder
            if (item.type === 'folder') {
                const items = await getAllItems();
                const updateChildren = async (parentId, oldPath, newPath) => {
                    const children = items.filter(i => i.parentId === parentId);
                    for (const child of children) {
                        const childNewPath = child.path.replace(oldPath, newPath);
                        await updateFile(child.id, { path: childNewPath });
                        if (child.type === 'folder') {
                            await updateChildren(child.id, child.path, childNewPath);
                        }
                    }
                };
                await updateChildren(id, item.path, newPath);
            }
        }

        async function moveItem(itemId, newParentId) {
            const item = await getItem(itemId);
            if (!item) return false;

            // Prevent moving item into itself
            if (itemId === newParentId) return false;

            // Prevent moving folder into its own descendant
            if (item.type === 'folder' && newParentId) {
                const items = await getAllItems();
                const isDescendant = (checkId, ancestorId) => {
                    const checkItem = items.find(i => i.id === checkId);
                    if (!checkItem || !checkItem.parentId) return false;
                    if (checkItem.parentId === ancestorId) return true;
                    return isDescendant(checkItem.parentId, ancestorId);
                };
                if (isDescendant(newParentId, itemId)) return false;
            }

            // Calculate new path
            const newPath = newParentId
                ? `${await getItemPath(newParentId)}/${item.name}`
                : item.name;

            // Update item
            await updateFile(itemId, { parentId: newParentId, path: newPath });

            // Update all children paths if folder
            if (item.type === 'folder') {
                const items = await getAllItems();
                const updateChildren = async (parentId, oldPath, newPath) => {
                    const children = items.filter(i => i.parentId === parentId);
                    for (const child of children) {
                        const childNewPath = child.path.replace(oldPath, newPath);
                        await updateFile(child.id, { path: childNewPath });
                        if (child.type === 'folder') {
                            await updateChildren(child.id, child.path, childNewPath);
                        }
                    }
                };
                await updateChildren(itemId, item.path, newPath);
            }

            return true;
        }

        async function getNextUntitledName() {
            const items = await getAllItems();
            const untitledFiles = items.filter(item => {
                if (item.type !== 'file') return false;

                // Strip extension and check if it matches Untitled pattern
                const nameWithoutExt = item.name.replace(/\.[^.]+$/, '');
                // Match "Untitled", "Untitled (N)", or "Untitled N"
                return nameWithoutExt.match(/^Untitled(\s\(?\d+\)?)?$/);
            });

            if (untitledFiles.length === 0) return 'Untitled';

            const numbers = untitledFiles.map(file => {
                // Strip extension before matching
                const nameWithoutExt = file.name.replace(/\.[^.]+$/, '');
                // Match both "Untitled (N)" and "Untitled N" formats
                const match = nameWithoutExt.match(/^Untitled\s\(?(\d+)\)?$/);
                return match ? parseInt(match[1]) : 0;
            });

            const maxNumber = Math.max(...numbers);
            return `Untitled (${maxNumber + 1})`;
        }

        // ===== Syntax Error Linters =====

        // JSON linter using built-in JSON.parse
        function jsonLinter(view) {
            const diagnostics = [];
            const code = view.state.doc.toString();

            if (code.trim() === '') return diagnostics; // Empty is valid

            try {
                JSON.parse(code);
            } catch (error) {
                // Try to extract position from error message
                const match = error.message.match(/position (\d+)/);
                let from = 0;

                if (match) {
                    from = parseInt(match[1]);
                } else {
                    // If no position, highlight the whole document
                    from = 0;
                }

                const to = Math.min(from + 1, view.state.doc.length);

                diagnostics.push({
                    from: from,
                    to: to,
                    severity: 'error',
                    message: error.message
                });
            }

            return diagnostics;
        }

        // HTML linter with tag matching validation
        function htmlLinter(view) {
            const diagnostics = [];
            const code = view.state.doc.toString();

            if (code.trim() === '') return diagnostics;

            // Self-closing/void HTML tags that don't need closing tags
            const voidTags = new Set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input',
                                      'link', 'meta', 'param', 'source', 'track', 'wbr']);

            // Stack to track opening tags
            const tagStack = [];

            // Regex to match HTML tags
            const tagRegex = /<\/?([a-zA-Z][a-zA-Z0-9]*)[^>]*>/g;
            let match;

            while ((match = tagRegex.exec(code)) !== null) {
                const fullTag = match[0];
                const tagName = match[1].toLowerCase();
                const isClosing = fullTag.startsWith('</');
                const isSelfClosing = fullTag.endsWith('/>') || voidTags.has(tagName);
                const tagStart = match.index;
                const tagEnd = match.index + fullTag.length;

                if (isClosing) {
                    // Closing tag
                    if (tagStack.length === 0) {
                        // Closing tag with no matching opening tag
                        diagnostics.push({
                            from: tagStart,
                            to: tagEnd,
                            severity: 'error',
                            message: `Unexpected closing tag </${tagName}>`
                        });
                    } else {
                        const lastOpen = tagStack[tagStack.length - 1];
                        if (lastOpen.name === tagName) {
                            // Matching pair, pop from stack
                            tagStack.pop();
                        } else {
                            // Mismatched closing tag
                            diagnostics.push({
                                from: tagStart,
                                to: tagEnd,
                                severity: 'error',
                                message: `Mismatched closing tag </${tagName}>, expected </${lastOpen.name}>`
                            });
                        }
                    }
                } else if (!isSelfClosing) {
                    // Opening tag that needs a closing tag
                    tagStack.push({
                        name: tagName,
                        start: tagStart,
                        end: tagEnd
                    });
                }
                // Self-closing tags are ignored (no push to stack)
            }

            // Check for unclosed tags remaining on the stack
            for (const tag of tagStack) {
                diagnostics.push({
                    from: tag.start,
                    to: tag.end,
                    severity: 'error',
                    message: `Unclosed tag <${tag.name}>`
                });
            }

            return diagnostics;
        }

        // XML linter using DOMParser with strict XML mode
        function xmlLinter(view) {
            const diagnostics = [];
            const code = view.state.doc.toString();

            if (code.trim() === '') return diagnostics;

            const parser = new DOMParser();
            const doc = parser.parseFromString(code, 'application/xml');

            // Check for parsererror element (XML parser is strict)
            const errors = doc.getElementsByTagName('parsererror');
            if (errors.length > 0) {
                const errorText = errors[0].textContent;
                // Try to extract line number from error message
                const lineMatch = errorText.match(/line (\d+)/i);

                if (lineMatch) {
                    const lineNum = parseInt(lineMatch[1]);
                    try {
                        const lineObj = view.state.doc.line(lineNum);
                        diagnostics.push({
                            from: lineObj.from,
                            to: lineObj.to,
                            severity: 'error',
                            message: errorText.split('\n')[0]
                        });
                    } catch (e) {
                        // If line number is invalid, highlight start
                        diagnostics.push({
                            from: 0,
                            to: Math.min(100, code.length),
                            severity: 'error',
                            message: errorText.split('\n')[0]
                        });
                    }
                } else {
                    // No line number, highlight the beginning
                    diagnostics.push({
                        from: 0,
                        to: Math.min(100, code.length),
                        severity: 'error',
                        message: errorText.split('\n')[0]
                    });
                }
            }

            return diagnostics;
        }

        // YAML linter using js-yaml
        function yamlLinter(view) {
            const diagnostics = [];
            const code = view.state.doc.toString();

            if (code.trim() === '') return diagnostics;

            try {
                jsYaml.load(code);
            } catch (error) {
                // Extract line and column from error
                let from = 0;
                let to = 1;

                if (error.mark) {
                    const line = error.mark.line + 1; // js-yaml uses 0-based lines
                    const col = error.mark.column;

                    try {
                        const lineObj = view.state.doc.line(line);
                        from = lineObj.from + col;
                        to = Math.min(from + 1, lineObj.to);
                    } catch (e) {
                        // If line is invalid, use start of document
                        from = 0;
                        to = 1;
                    }
                }

                diagnostics.push({
                    from: from,
                    to: to,
                    severity: 'error',
                    message: error.message
                });
            }

            return diagnostics;
        }

        // ===== Editor State =====
        const languageMap = {
            html: () => [html(), linter(htmlLinter)],
            json: () => [json(), linter(jsonLinter)],
            xml: () => [xml(), linter(xmlLinter)],
            yaml: () => [yaml(), linter(yamlLinter)],
            plaintext: () => []
        };

        const extensionMap = {
            'html': 'html',
            'htm': 'html',
            'json': 'json',
            'xml': 'xml',
            'yaml': 'yaml',
            'yml': 'yaml',
            'txt': 'plaintext'
        };

        // Regex presets for random string generation
        const REGEX_PRESETS = {
            'alpha': '[a-zA-Z]',
            'numeric': '[0-9]',
            'alphanumeric': '[a-zA-Z0-9]',
            'special': '[a-zA-Z0-9!@#$%^&*()_+\\-=\\[\\]{}|;:,.<>?]'
        };

        const isMac = navigator.platform?.toLowerCase().includes('mac');
        let currentTheme = 'dark';
        let currentFileId = null;
        let isDirty = false;
        let isLoading = false; // Track when loading file to prevent marking as dirty
        let view;
        let leftView = null;
        let rightView = null;
        let leftFileId = null;
        let rightFileId = null;
        let leftLanguage = 'plaintext';
        let rightLanguage = 'plaintext';
        let activePane = 'left';
        let isSplitEditor = false;
        let currentLanguage = 'plaintext';
        let isSplitSyncing = false;

        // Temporary file management - files not yet saved to IndexedDB
        let tempFiles = new Map(); // Map<tempId, {name, content, type}> - temporary unsaved files
        let nextTempId = -1; // Use negative IDs for temporary files

        // Draft content management - store unsaved edits in memory
        let draftContent = new Map(); // Map<fileId, string> - unsaved edits per file
        let fileDirtyState = new Map(); // Map<fileId, boolean> - per-file dirty state

        // File comparison state
        let isComparing = false;
        let mergeView = null; // MergeView instance for diff comparison
        let comparisonState = null; // Store content and options for current comparison
        let comparisonFormatEnabled = false; // Track whether formatted view is active
        let comparisonViewMode = 'side-by-side';

        // ===== Editor Functions =====
        function buildEditorExtensions(fileId, pane, readonly) {
            const extensions = [
                basicSetup,
                lintGutter(), // Add lint gutter for error markers
                keymap.of([indentWithTab]),
                search({ top: true }),
                highlightSelectionMatches(),
                EditorView.domEventHandlers({
                    focus: () => {
                        if (isSplitEditor) {
                            setActivePane(pane);
                        }
                    }
                }),
                EditorView.updateListener.of((update) => {
                    if (fileId === currentFileId) {
                        view = update.view;
                    }
                    if (update.selectionSet && fileId === currentFileId) {
                        updateCursorInfo(update.view);
                    }
                    if (isSplitEditor && !isSplitSyncing && update.docChanged && fileId) {
                        const otherView = pane === 'left' ? rightView : leftView;
                        const otherFileId = pane === 'left' ? rightFileId : leftFileId;
                        if (otherView && otherFileId === fileId) {
                            isSplitSyncing = true;
                            try {
                                const syncedTr = otherView.state.update({
                                    changes: update.changes,
                                    annotations: Transaction.addToHistory.of(false)
                                });
                                otherView.update([syncedTr]);
                            } finally {
                                isSplitSyncing = false;
                            }
                        }
                    }
                    if (update.docChanged && !isLoading && fileId) {
                        const wasDirty = fileDirtyState.get(fileId) ?? false;
                        fileDirtyState.set(fileId, true);
                        if (fileId === currentFileId) {
                            isDirty = true;
                        }
                        saveDraftContent(fileId, update.state.doc.toString());
                        if (!wasDirty) {
                            renderFileTree();
                        }
                    }
                }),
                EditorView.editable.of(!readonly)
            ];

            return extensions;
        }

        function applyLanguageExtensions(extensions, language, theme = currentTheme) {
            const langExtension = languageMap[language];
            if (langExtension) {
                const langExts = langExtension();
                if (Array.isArray(langExts)) {
                    extensions.push(...langExts);
                } else {
                    extensions.push(langExts);
                }
            }
            if (theme === 'dark') {
                extensions.push(oneDark);
            }
        }

        function destroyPaneEditors() {
            if (leftView) {
                leftView.destroy();
            }
            if (rightView) {
                rightView.destroy();
            }
            leftView = null;
            rightView = null;
        }

        function ensureSplitLayout() {
            const container = document.getElementById('editor-content');
            container.innerHTML = '';
            const leftPane = document.createElement('div');
            leftPane.className = 'editor-pane editor-pane-left';
            const rightPane = document.createElement('div');
            rightPane.className = 'editor-pane editor-pane-right';

            const leftHeader = document.createElement('div');
            leftHeader.className = 'pane-header';
            leftHeader.id = 'pane-left-header';
            const leftTitle = document.createElement('span');
            leftTitle.className = 'pane-title';
            leftTitle.id = 'pane-left-title';
            leftHeader.appendChild(leftTitle);
            const leftClose = document.createElement('button');
            leftClose.className = 'pane-close';
            leftClose.type = 'button';
            leftClose.textContent = '‚úï';
            leftClose.title = 'Close Left Pane';
            leftClose.addEventListener('click', () => closeSplitPane('left'));
            leftHeader.appendChild(leftClose);

            const rightHeader = document.createElement('div');
            rightHeader.className = 'pane-header';
            rightHeader.id = 'pane-right-header';
            const rightTitle = document.createElement('span');
            rightTitle.className = 'pane-title';
            rightTitle.id = 'pane-right-title';
            rightHeader.appendChild(rightTitle);
            const rightClose = document.createElement('button');
            rightClose.className = 'pane-close';
            rightClose.type = 'button';
            rightClose.textContent = '‚úï';
            rightClose.title = 'Close Right Pane';
            rightClose.addEventListener('click', () => closeSplitPane('right'));
            rightHeader.appendChild(rightClose);

            const leftContent = document.createElement('div');
            leftContent.className = 'pane-content';
            leftContent.id = 'pane-left-content';
            const rightContent = document.createElement('div');
            rightContent.className = 'pane-content';
            rightContent.id = 'pane-right-content';

            leftPane.appendChild(leftHeader);
            leftPane.appendChild(leftContent);
            rightPane.appendChild(rightHeader);
            rightPane.appendChild(rightContent);

            container.appendChild(leftPane);
            container.appendChild(rightPane);
        }

        function updatePaneTitle(pane, file) {
            const titleEl = document.getElementById(`pane-${pane}-title`);
            if (!titleEl) return;
            if (!file) {
                titleEl.textContent = pane === 'left' ? 'Left Pane' : 'Right Pane';
            } else {
                titleEl.textContent = file.name;
            }
        }

        function createPaneEditor(pane, fileId, content, language, readonly = false) {
            const containerId = pane === 'left' ? 'pane-left-content' : 'pane-right-content';
            const container = document.getElementById(containerId);
            if (!container) return null;
            container.innerHTML = '';

            const extensions = buildEditorExtensions(fileId, pane, readonly);
            applyLanguageExtensions(extensions, language, currentTheme);

            const paneView = new EditorView({
                doc: content,
                extensions: extensions,
                parent: container
            });

            if (pane === 'left') {
                if (leftView) {
                    leftView.destroy();
                }
                leftView = paneView;
                leftFileId = fileId;
                leftLanguage = language;
            } else {
                if (rightView) {
                    rightView.destroy();
                }
                rightView = paneView;
                rightFileId = fileId;
                rightLanguage = language;
            }

            return paneView;
        }

        function createSingleEditor(content = '', language = 'plaintext', theme = 'dark', readonly = false, fileId = currentFileId) {
            const container = document.getElementById('editor-content');
            container.innerHTML = '';

            const extensions = buildEditorExtensions(fileId, 'left', readonly);
            applyLanguageExtensions(extensions, language, theme);

            destroyPaneEditors();
            view = new EditorView({
                doc: content,
                extensions: extensions,
                parent: container
            });
            leftView = view;
            leftFileId = fileId;
            leftLanguage = language;
            activePane = 'left';
            currentLanguage = language;
            currentFileId = fileId;

            updateCursorInfo(view);
        }

        function setActivePane(pane) {
            activePane = pane;
            if (!isSplitEditor) {
                activePane = 'left';
            }
            if (activePane === 'left') {
                view = leftView;
                currentFileId = leftFileId;
                currentLanguage = leftLanguage;
            } else {
                view = rightView;
                currentFileId = rightFileId;
                currentLanguage = rightLanguage;
            }
            isDirty = currentFileId ? (fileDirtyState.get(currentFileId) ?? false) : false;
            updateCursorInfo(view);

            const leftHeader = document.getElementById('pane-left-header');
            const rightHeader = document.getElementById('pane-right-header');
            if (leftHeader && rightHeader) {
                leftHeader.classList.toggle('active', activePane === 'left');
                rightHeader.classList.toggle('active', activePane === 'right');
            }
        }

        async function setSplitView(enabled) {
            if (enabled && isComparing) {
                updateStatus('Close comparison view to enable split view');
                return;
            }
            if (enabled === isSplitEditor) return;

            const editorContainer = document.getElementById('editor-container');
            if (enabled) {
                isSplitEditor = true;
                editorContainer.classList.add('editor-split');
                ensureSplitLayout();

                if (!leftFileId && currentFileId) {
                    leftFileId = currentFileId;
                }
                if (!rightFileId && leftFileId) {
                    rightFileId = leftFileId;
                    rightLanguage = leftLanguage;
                }

                if (leftFileId) {
                    const leftFile = await getItem(leftFileId);
                    const leftContent = draftContent.has(leftFileId)
                        ? draftContent.get(leftFileId)
                        : (leftFile?.content ?? '');
                    const leftLang = leftFile ? detectLanguageFromFilename(leftFile.name) : leftLanguage;
                    leftLanguage = leftLang;
                    createPaneEditor('left', leftFileId, leftContent, leftLang);
                    updatePaneTitle('left', leftFile);
                } else {
                    createPaneEditor('left', null, '', 'plaintext', true);
                    updatePaneTitle('left', null);
                }

                if (rightFileId) {
                    const rightFile = await getItem(rightFileId);
                    const rightContent = draftContent.has(rightFileId)
                        ? draftContent.get(rightFileId)
                        : (rightFile?.content ?? '');
                    const rightLang = rightFile ? detectLanguageFromFilename(rightFile.name) : rightLanguage;
                    rightLanguage = rightLang;
                    createPaneEditor('right', rightFileId, rightContent, rightLang);
                    updatePaneTitle('right', rightFile);
                } else {
                    createPaneEditor('right', null, '', 'plaintext', true);
                    updatePaneTitle('right', null);
                }

                setActivePane(activePane || 'left');
            } else {
                isSplitEditor = false;
                editorContainer.classList.remove('editor-split');
                const content = view ? view.state.doc.toString() : '';
                const lang = currentLanguage || 'plaintext';
                destroyPaneEditors();
                createSingleEditor(content, lang, currentTheme, false, currentFileId);
            }
        }

        function disableSplitViewForComparison() {
            if (!isSplitEditor) return;
            isSplitEditor = false;
            const editorContainer = document.getElementById('editor-container');
            editorContainer.classList.remove('editor-split');
            destroyPaneEditors();
        }

        async function closeSplitPane(pane) {
            if (!isSplitEditor) return;
            const remainingPane = pane === 'left' ? 'right' : 'left';
            const remainingFileId = pane === 'left' ? rightFileId : leftFileId;
            const remainingLanguage = pane === 'left' ? rightLanguage : leftLanguage;
            const remainingContent = remainingPane === 'left'
                ? (leftView ? leftView.state.doc.toString() : '')
                : (rightView ? rightView.state.doc.toString() : '');

            isSplitEditor = false;
            const editorContainer = document.getElementById('editor-container');
            editorContainer.classList.remove('editor-split');
            destroyPaneEditors();

            leftFileId = remainingFileId;
            rightFileId = null;
            leftLanguage = remainingLanguage || 'plaintext';
            rightLanguage = 'plaintext';
            activePane = 'left';

            createSingleEditor(remainingContent, leftLanguage, currentTheme, false, remainingFileId);
            if (remainingFileId) {
                await persistLastOpenedFile(remainingFileId);
            }
            renderFileTree();
        }

        async function updateCursorInfo(sourceView = view) {
            if (!sourceView) return;
            const state = sourceView.state;
            const selection = state.selection.main;
            const pos = selection.head;
            const line = state.doc.lineAt(pos);
            const lineNumber = line.number;
            const col = pos - line.from + 1;

            // Calculate lengths
            const totalLength = state.doc.length;
            const hasSelection = selection.anchor !== selection.head;
            const selectedLength = hasSelection
                ? Math.abs(selection.head - selection.anchor)
                : 0;

            let cursorText = `Ln ${lineNumber}, Col ${col}`;

            // Add length info
            if (hasSelection) {
                cursorText += ` | ${selectedLength}/${totalLength}`;
            } else {
                cursorText += ` | Length: ${totalLength}`;
            }

            // Add JSON path if current file is JSON
            if (currentFileId) {
                const file = await getItem(currentFileId);
                if (file && detectLanguageFromFilename(file.name) === 'json') {
                    const jsonPath = getJsonPath(state);
                    if (jsonPath) {
                        cursorText = `${jsonPath} | ${cursorText}`;
                    }
                }
            }

            // Check if selected text is a Unix timestamp
            if (hasSelection) {
                const selectedText = state.doc.sliceString(
                    Math.min(selection.anchor, selection.head),
                    Math.max(selection.anchor, selection.head)
                );
                if (isUnixTimestamp(selectedText)) {
                    const timestamp = parseInt(selectedText.trim(), 10);
                    const formatted = formatUnixTimestamp(timestamp);
                    if (formatted) {
                        cursorText += ` | üìÖ ${formatted}`;
                    }
                }
            }

            document.getElementById('cursor-info').textContent = cursorText;
        }

        // ===== Draft Content Management =====
        function saveDraftContent(fileId, contentOverride = null) {
            if (!fileId) return;
            const content = contentOverride ?? view?.state.doc.toString() ?? '';
            draftContent.set(fileId, content);
            const existingDirty = fileDirtyState.get(fileId);
            fileDirtyState.set(fileId, existingDirty ?? isDirty);
        }

        function clearDraft(fileId) {
            draftContent.delete(fileId);
            fileDirtyState.delete(fileId);
        }

        function updateLanguage(language) {
            if (!view || !currentFileId) return;
            const content = view.state.doc.toString();
            isLoading = true;
            if (isSplitEditor) {
                const pane = activePane;
                createPaneEditor(pane, currentFileId, content, language);
                if (pane === 'left') {
                    leftLanguage = language;
                } else {
                    rightLanguage = language;
                }
                setActivePane(pane);
            } else {
                createSingleEditor(content, language, currentTheme, false, currentFileId);
                leftLanguage = language;
                setActivePane('left');
            }
            isLoading = false;
        }

        function updateStatus(message) {
            const statusInfo = document.getElementById('status-info');
            statusInfo.textContent = message;
            setTimeout(() => {
                statusInfo.textContent = 'Ready';
            }, 3000);
        }

        // Check if text is a valid Unix timestamp
        function isUnixTimestamp(text) {
            const trimmed = text.trim();
            const num = parseInt(trimmed, 10);
            // Valid timestamp: integer, matches original string (no decimals), reasonable range (1970-9999)
            return !isNaN(num) &&
                   trimmed === num.toString() &&
                   num > 0 &&
                   num < 253402300799;
        }

        // Format Unix timestamp to human-readable date
        function formatUnixTimestamp(timestamp) {
            try {
                const date = new Date(timestamp * 1000); // Convert seconds to milliseconds
                return date.toLocaleString();
            } catch (e) {
                return null;
            }
        }

        // Get JSON path from cursor position
        function getJsonPath(state) {
            try {

                const tree = state.tree

                // Validate tree is populated
                if (!tree || tree.length === 0) {
                    return null;
                }

                const pos = state.selection.main.head;
                let node = tree.resolve(pos, 0);
                const path = [];

                while (node) {

                    // Handle object properties
                    if (node.name === "Property") {
                        // Find PropertyName child using proper iteration
                        let child = node.firstChild;
                        while (child) {
                            if (child.name === "PropertyName") {
                                let name = state.doc.sliceString(child.from, child.to);
                                // Remove quotes from property name
                                name = name.replace(/^["']|["']$/g, '');

                                // Check if path[0] is an array index marker (starts with '[')
                                if (path.length > 0 && path[0].startsWith('[')) {
                                    name = name + path[0]; // Combine property with array index
                                    path.shift(); // Remove the array index marker
                                }

                                path.unshift(name);
                                break;
                            }
                            child = child.nextSibling;
                        }
                    }
                    // Handle array elements (but not bracket tokens)
                    else if (node.parent && node.parent.name === "Array" &&
                        node.name !== "[" && node.name !== "]") {
                        // Count how many siblings come before this node to get index
                        let index = 0;
                        let sibling = node.prevSibling;
                        while (sibling) {
                            // Only count actual JSON value nodes (array elements)
                            if (sibling.name === "Object" ||
                                sibling.name === "Array" ||
                                sibling.name === "String" ||
                                sibling.name === "Number" ||
                                sibling.name === "True" ||
                                sibling.name === "False" ||
                                sibling.name === "Null") {
                                index++;
                            }
                            sibling = sibling.prevSibling;
                        }
                        // Store array index as separate marker to be combined with parent property
                        path.unshift(`[${index}]`);
                    }

                    // Move to parent
                    node = node.parent;

                    // Stop at root
                    if (!node || node.name === "JsonText") break;
                }

                return path.length > 0 ? path.join('.') : 'root';
            } catch (e) {
                console.error('Error in getJsonPath:', e);
                return '';
            }
        }

        // Reconstruct nested JSON structure from path and value
        function reconstructJsonFromPath(path, value) {
            if (path === 'root') {
                // At root level, return value as-is
                return value;
            }

            // Split path into segments (e.g., "information.details[1].data" -> ["information", "details[1]", "data"])
            const segments = path.split('.');

            // Parse each segment to extract property name and optional array index
            const parsedSegments = segments.map(seg => {
                const arrayMatch = seg.match(/^(.+?)\[(\d+)\]$/);
                if (arrayMatch) {
                    return { property: arrayMatch[1], index: parseInt(arrayMatch[2]) };
                }
                return { property: seg, index: null };
            });

            // Build nested structure from inside-out (deepest to shallowest)
            let result = value;

            for (let i = parsedSegments.length - 1; i >= 0; i--) {
                const segment = parsedSegments[i];

                if (segment.index !== null) {
                    // Create array with value as first element (ignore original index)
                    const arr = [result];
                    // Wrap array in object with property name
                    result = { [segment.property]: arr };
                } else {
                    // Wrap in object with property name
                    result = { [segment.property]: result };
                }
            }

            return result;
        }

        // Extract JSON subtree based on current cursor position and path
        async function extractJsonSubtree() {
            if (!view) return false;

            const state = view.state;

            // Only works for JSON files
            if (currentFileId) {
                const file = await getItem(currentFileId);
                if (!file || detectLanguageFromFilename(file.name) !== 'json') {
                    updateStatus('This feature only works with JSON files');
                    return false;
                }
            } else {
                updateStatus('No file is currently open');
                return false;
            }

            // Get the JSON path
            const path = getJsonPath(state);
            if (!path) {
                updateStatus('Could not determine JSON path');
                return false;
            }

            const tree = state.tree;

            if (!tree || tree.length === 0) {
                updateStatus('JSON parsing failed');
                return false;
            }

            // Find the node at cursor
            const pos = state.selection.main.head;
            let node = tree.resolve(pos, 0);

            // Check if cursor is on or inside an array element
            let isArrayElement = false;
            let checkNode = node;
            while (checkNode && checkNode.name !== "Property" && checkNode.name !== "JsonText") {
                if (checkNode.parent && checkNode.parent.name === "Array" &&
                    checkNode.name !== "[" && checkNode.name !== "]") {
                    isArrayElement = true;
                    // Move node pointer to the actual array element (the value node)
                    node = checkNode;
                    break;
                }
                checkNode = checkNode.parent;
            }

            if (!isArrayElement) {
                // Cursor is on property value - navigate up to Property node
                while (node && node.name !== "Property") {
                    node = node.parent;
                    if (!node || node.name === "JsonText") {
                        node = null;
                        break;
                    }
                }

                // Get the value child of the Property node (skip PropertyName)
                if (node && node.name === "Property") {
                    let child = node.firstChild;
                    const valueNodeTypes = ['Object', 'Array', 'String', 'Number', 'True', 'False', 'Null'];

                    while (child) {
                        if (valueNodeTypes.includes(child.name)) {
                            node = child;
                            break;
                        }
                        child = child.nextSibling;
                    }
                }
            }
            // If isArrayElement is true, node already points to the array element - use it directly

            if (!node) {
                updateStatus('Could not find JSON value at cursor');
                return false;
            }

            // Extract the value text
            const valueText = state.doc.sliceString(node.from, node.to);

            // Parse the value
            let value;
            try {
                value = JSON.parse(valueText);
            } catch (e) {
                updateStatus('Invalid JSON at cursor position');
                return false;
            }

            // Reconstruct the minimal JSON structure
            const reconstructed = reconstructJsonFromPath(path, value);

            // Format with 2-space indentation
            const formattedJson = JSON.stringify(reconstructed, null, 2);

            const name = `${await getNextUntitledName()}.json`;
            const tempId = nextTempId--;
            tempFiles.set(tempId, {
                id: tempId,
                name: name,
                path: `/${name}`,
                content: formattedJson,
                type: 'file',
                parentId: null,
                createdAt: new Date(),
                updatedAt: new Date()
            });

            await openFile(tempId, isSplitEditor ? activePane : 'left');
            isDirty = true;
            fileDirtyState.set(tempId, true);
            updateStatus(`Created ${name}`);
            return true;
        }

        // ===== JWT/JWE Settings Management =====
        // JWT Settings
        let jwtSettings = {
            algorithm: 'HS256',
            secretKey: '',
            publicKeyPem: '',
            privateKeyPem: '',
            autoIat: true,
            autoExp: false,
            expDuration: 1,
            expUnit: 'hours'
        };

        // JWE Settings (separate from JWT)
        let jweSettings = {
            algorithm: 'dir',
            secretKey: '',
            publicKeyPem: '',
            privateKeyPem: '',
            autoIat: true,
            autoExp: false,
            expDuration: 1,
            expUnit: 'hours'
        };

        async function initJWTSettings() {
            const settings = await loadJWTSettings();
            if (settings) {
                jwtSettings = settings;
            } else {
                // Initialize with default settings
                await saveJWTSettings(jwtSettings);
            }
            updateJWTSettingsUI();
        }

        async function loadJWTSettings() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['jwtSettings'], 'readonly');
                const store = transaction.objectStore('jwtSettings');
                const request = store.get('default');

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function saveJWTSettings(settings) {
            const settingsToSave = {
                id: 'default',
                ...settings
            };

            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['jwtSettings'], 'readwrite');
                const store = transaction.objectStore('jwtSettings');
                const request = store.put(settingsToSave);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function updateJWTSettingsUI() {
            const algorithmSelect = document.getElementById('jwt-algorithm');
            const secretKeyInput = document.getElementById('jwt-secret-key');
            const publicKeyTextarea = document.getElementById('jwt-public-key');
            const privateKeyTextarea = document.getElementById('jwt-private-key');
            const autoIatCheckbox = document.getElementById('jwt-auto-iat');
            const autoExpCheckbox = document.getElementById('jwt-auto-exp');
            const expDurationInput = document.getElementById('jwt-exp-duration');
            const expUnitSelect = document.getElementById('jwt-exp-unit');
            const secretKeySection = document.getElementById('jwt-secret-key-section');
            const keypairSection = document.getElementById('jwt-keypair-section');
            const expConfigSection = document.getElementById('exp-config-section');

            algorithmSelect.value = jwtSettings.algorithm;
            secretKeyInput.value = jwtSettings.secretKey || '';
            autoIatCheckbox.checked = jwtSettings.autoIat;
            autoExpCheckbox.checked = jwtSettings.autoExp;
            expDurationInput.value = jwtSettings.expDuration;
            expUnitSelect.value = jwtSettings.expUnit;

            // Show/hide sections based on algorithm
            if (jwtSettings.algorithm.startsWith('HS')) {
                secretKeySection.style.display = '';
                keypairSection.style.display = 'none';
            } else {
                secretKeySection.style.display = 'none';
                keypairSection.style.display = '';

                // Display PEM keys (not JWK)
                publicKeyTextarea.value = jwtSettings.publicKeyPem || '';
                privateKeyTextarea.value = jwtSettings.privateKeyPem || '';
            }

            // Show/hide exp config section
            expConfigSection.style.display = jwtSettings.autoExp ? '' : 'none';
        }

        function updateJWESettingsUI() {
            const algorithmSelect = document.getElementById('jwe-algorithm');
            const secretKeyInput = document.getElementById('jwe-secret-key');
            const publicKeyTextarea = document.getElementById('jwe-public-key');
            const privateKeyTextarea = document.getElementById('jwe-private-key');
            const autoIatCheckbox = document.getElementById('jwe-auto-iat');
            const autoExpCheckbox = document.getElementById('jwe-auto-exp');
            const expDurationInput = document.getElementById('jwe-exp-duration');
            const expUnitSelect = document.getElementById('jwe-exp-unit');
            const expConfigSection = document.getElementById('jwe-exp-config-section');
            const secretKeySection = document.getElementById('jwe-secret-key-section');
            const keypairSection = document.getElementById('jwe-keypair-section');

            algorithmSelect.value = jweSettings.algorithm;
            secretKeyInput.value = jweSettings.secretKey || '';
            publicKeyTextarea.value = jweSettings.publicKeyPem || '';
            privateKeyTextarea.value = jweSettings.privateKeyPem || '';
            autoIatCheckbox.checked = jweSettings.autoIat;
            autoExpCheckbox.checked = jweSettings.autoExp;
            expDurationInput.value = jweSettings.expDuration;
            expUnitSelect.value = jweSettings.expUnit;

            // Show fields based on algorithm
            secretKeySection.style.display = jweSettings.algorithm === 'dir' ? '' : 'none';
            keypairSection.style.display = jweSettings.algorithm === 'ECDH-ES' ? '' : 'none';

            // Show/hide exp config section
            expConfigSection.style.display = jweSettings.autoExp ? '' : 'none';
        }

        async function initJWESettings() {
            const settings = await loadJWESettings();
            if (settings) {
                jweSettings = { ...jweSettings, ...settings };
            } else {
                // Initialize with default settings
                await saveJWESettings(jweSettings);
            }
            updateJWESettingsUI();
        }

        async function loadJWESettings() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['jweSettings'], 'readonly');
                const store = transaction.objectStore('jweSettings');
                const request = store.get('default');

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function saveJWESettings(settings) {
            const settingsToSave = {
                id: 'default',
                ...settings
            };

            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['jweSettings'], 'readwrite');
                const store = transaction.objectStore('jweSettings');
                const request = store.put(settingsToSave);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function calculateExpiration(duration, unit) {
            const now = Math.floor(Date.now() / 1000);
            const multipliers = {
                seconds: 1,
                minutes: 60,
                hours: 3600,
                days: 86400,
                months: 2592000,  // 30 days
                years: 31536000   // 365 days
            };
            return now + (duration * multipliers[unit]);
        }

        function getExpirationString(duration, unit) {
            const unitMap = {
                seconds: 's',
                minutes: 'm',
                hours: 'h',
                days: 'd',
                months: 'd',  // Convert months to days
                years: 'd'    // Convert years to days
            };

            if (unit === 'months') {
                return `${duration * 30}d`;
            } else if (unit === 'years') {
                return `${duration * 365}d`;
            } else {
                return `${duration}${unitMap[unit]}`;
            }
        }

        // ===== JWT/JWE Key Management =====
        async function generateKeyPair() {
            const algorithm = jwtSettings.algorithm;

            if (algorithm.startsWith('HS')) {
                updateStatus('HS algorithms use symmetric keys, not key pairs');
                return false;
            }

            try {
                updateStatus(`Generating ${algorithm} key pair...`);

                const { publicKey, privateKey } = await jose.generateKeyPair(algorithm, {
                    extractable: true
                });

                // Export to PEM format for storage
                const publicKeyPem = await exportSPKI(publicKey);
                const privateKeyPem = await exportPKCS8(privateKey);

                // Update settings
                jwtSettings.publicKeyPem = publicKeyPem;
                jwtSettings.privateKeyPem = privateKeyPem;

                // Update UI
                document.getElementById('jwt-public-key').value = publicKeyPem;
                document.getElementById('jwt-private-key').value = privateKeyPem;

                updateStatus(`${algorithm} key pair generated successfully`);
                return true;
            } catch (e) {
                updateStatus(`Failed to generate key pair: ${e.message}`);
                return false;
            }
        }

        async function generateJWEKeyPair() {
            if (jweSettings.algorithm !== 'ECDH-ES') {
                updateStatus('Switch JWE algorithm to ECDH-ES to generate a key pair');
                return false;
            }

            try {
                updateStatus('Generating ECDH-ES key pair...');

                const { publicKey, privateKey } = await jose.generateKeyPair('ECDH-ES', {
                    crv: 'P-256',
                    extractable: true
                });

                const publicKeyPem = await exportSPKI(publicKey);
                const privateKeyPem = await exportPKCS8(privateKey);

                jweSettings.publicKeyPem = publicKeyPem;
                jweSettings.privateKeyPem = privateKeyPem;

                document.getElementById('jwe-public-key').value = publicKeyPem;
                document.getElementById('jwe-private-key').value = privateKeyPem;

                updateStatus('ECDH-ES key pair generated successfully');
                return true;
            } catch (e) {
                updateStatus(`Failed to generate JWE key pair: ${e.message}`);
                return false;
            }
        }

        async function getKeyForAlgorithm() {
            const algorithm = jwtSettings.algorithm;

            if (algorithm.startsWith('HS')) {
                // Symmetric key from string
                const secretKey = jwtSettings.secretKey;

                // Validate key length
                const minLengths = {
                    'HS256': 32,
                    'HS384': 48,
                    'HS512': 64
                };

                const minLength = minLengths[algorithm];
                if (!secretKey || secretKey.length < minLength) {
                    throw new Error(`Secret key must be at least ${minLength} characters for ${algorithm}`);
                }

                // Convert string to Uint8Array
                return new TextEncoder().encode(secretKey);
            } else {
                // Asymmetric key from PEM
                if (!jwtSettings.privateKeyPem || jwtSettings.privateKeyPem.trim() === '') {
                    throw new Error(`No private key found. Please generate or paste a key pair in JWT settings.`);
                }

                // Validate PEM format
                if (!jwtSettings.privateKeyPem.includes('-----BEGIN PRIVATE KEY-----')) {
                    throw new Error('Invalid private key format. Expected PEM PKCS8 format.');
                }

                // Import private key from PEM
                return await importPKCS8(jwtSettings.privateKeyPem, algorithm);
            }
        }

        async function getPublicKeyForAlgorithm() {
            const algorithm = jwtSettings.algorithm;

            if (algorithm.startsWith('HS')) {
                // Symmetric key - same as signing key
                return await getKeyForAlgorithm();
            } else {
                // Asymmetric key - use public key for verification
                if (!jwtSettings.publicKeyPem || jwtSettings.publicKeyPem.trim() === '') {
                    throw new Error(`No public key found. Please generate or paste a key pair in JWT settings.`);
                }

                // Validate PEM format
                if (!jwtSettings.publicKeyPem.includes('-----BEGIN PUBLIC KEY-----')) {
                    throw new Error('Invalid public key format. Expected PEM SPKI format.');
                }

                return await importSPKI(jwtSettings.publicKeyPem, algorithm);
            }
        }

        async function copyToClipboard(text, description) {
            try {
                await navigator.clipboard.writeText(text);
                updateStatus(`${description} copied to clipboard`);
                return true;
            } catch (e) {
                updateStatus(`Failed to copy: ${e.message}`);
                return false;
            }
        }

        function openResultInNewTab(title, content) {
            const newWindow = window.open();

            if (!newWindow) {
                updateStatus('Please allow pop-ups to view the result in a new tab');
                return false;
            }

            const doc = newWindow.document;
            doc.open();
            doc.write(`<!DOCTYPE html><html><head><title>${title}</title></head><body><pre id="content"></pre></body></html>`);
            doc.close();

            doc.body.style.margin = '0';
            doc.body.style.padding = '12px';
            doc.body.style.background = '#0f0f0f';
            doc.body.style.color = '#e6e6e6';
            doc.body.style.fontFamily = 'monospace';

            const pre = doc.getElementById('content');
            pre.textContent = content;
            pre.style.whiteSpace = 'pre-wrap';
            pre.style.wordBreak = 'break-word';
            pre.style.margin = '0';
            pre.style.padding = '0';

            return true;
        }

        // ===== JWT Operations =====
        async function signJWT() {
            if (!view) {
                updateStatus('No editor available');
                return false;
            }

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            let text;

            if (hasSelection) {
                text = state.doc.sliceString(
                    Math.min(selection.anchor, selection.head),
                    Math.max(selection.anchor, selection.head)
                ).trim();
            } else {
                text = state.doc.toString().trim();
            }

            if (!text) {
                updateStatus('No content to sign');
                return false;
            }

            try {
                // Parse the content as JSON for the payload
                let payload;
                try {
                    payload = JSON.parse(text);
                } catch (e) {
                    updateStatus('Content must be valid JSON for JWT payload');
                    return false;
                }

                // Get the signing key
                const key = await getKeyForAlgorithm();

                // Create JWT builder
                let jwtBuilder = new jose.SignJWT(payload)
                    .setProtectedHeader({ alg: jwtSettings.algorithm });

                // Add auto IAT if enabled
                if (jwtSettings.autoIat) {
                    jwtBuilder = jwtBuilder.setIssuedAt();
                }

                // Add auto EXP if enabled
                if (jwtSettings.autoExp) {
                    const expString = getExpirationString(jwtSettings.expDuration, jwtSettings.expUnit);
                    jwtBuilder = jwtBuilder.setExpirationTime(expString);
                }

                // Sign the JWT
                const jwt = await jwtBuilder.sign(key);

                openResultInNewTab('Signed JWT', jwt);

                updateStatus(`JWT signed successfully with ${jwtSettings.algorithm} (opened in new tab)`);
                return true;
            } catch (e) {
                updateStatus(`Failed to sign JWT: ${e.message}`);
                return false;
            }
        }

        async function verifyJWT() {
            if (!view) {
                updateStatus('No editor available');
                return false;
            }

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            let text, from, to;

            if (hasSelection) {
                from = Math.min(selection.anchor, selection.head);
                to = Math.max(selection.anchor, selection.head);
                text = state.doc.sliceString(from, to).trim();
            } else {
                from = 0;
                to = state.doc.length;
                text = state.doc.toString().trim();
            }

            if (!text) {
                updateStatus('No JWT to verify');
                return false;
            }

            try {
                // Get the verification key (public key for asymmetric, secret for symmetric)
                const key = await getPublicKeyForAlgorithm();

                // Verify the JWT
                const { payload, protectedHeader } = await jose.jwtVerify(text, key);

                // Format the payload as JSON
                const formattedPayload = JSON.stringify(payload, null, 2);

                // Replace content with decoded payload
                view.dispatch({
                    changes: { from, to, insert: formattedPayload }
                });

                updateStatus(`JWT verified successfully with ${protectedHeader.alg}`);
                return true;
            } catch (e) {
                if (e.code === 'ERR_JWT_EXPIRED') {
                    updateStatus('JWT verification failed: Token has expired');
                } else if (e.code === 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED') {
                    updateStatus('JWT verification failed: Invalid signature');
                } else {
                    updateStatus(`JWT verification failed: ${e.message}`);
                }
                return false;
            }
        }

        async function decodeJWTWithoutVerify() {
            if (!view) {
                updateStatus('No editor available');
                return false;
            }

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            let text, from, to;

            if (hasSelection) {
                from = Math.min(selection.anchor, selection.head);
                to = Math.max(selection.anchor, selection.head);
                text = state.doc.sliceString(from, to).trim();
            } else {
                from = 0;
                to = state.doc.length;
                text = state.doc.toString().trim();
            }

            if (!text) {
                updateStatus('No JWT to decode');
                return false;
            }

            try {
                // Use jose.decodeJwt() which does NOT verify signature
                const payload = jose.decodeJwt(text);

                // Format as pretty JSON
                const formattedPayload = JSON.stringify(payload, null, 2);

                // Replace content with decoded payload
                view.dispatch({
                    changes: { from, to, insert: formattedPayload }
                });

                updateStatus('JWT decoded successfully (signature not verified)');
                return true;

            } catch (e) {
                updateStatus(`Failed to decode JWT: ${e.message}`);
                return false;
            }
        }

        // ===== JWE Operations =====
        async function encryptJWE() {
            if (!view) {
                updateStatus('No editor available');
                return false;
            }

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            let text;

            if (hasSelection) {
                text = state.doc.sliceString(
                    Math.min(selection.anchor, selection.head),
                    Math.max(selection.anchor, selection.head)
                ).trim();
            } else {
                text = state.doc.toString().trim();
            }

            if (!text) {
                updateStatus('No content to encrypt');
                return false;
            }

            try {
                // Parse the content as JSON for the payload
                let payload;
                try {
                    payload = JSON.parse(text);
                } catch (e) {
                    updateStatus('Content must be valid JSON for JWE payload');
                    return false;
                }

                const algorithm = jweSettings.algorithm || 'dir';

                // Create JWE builder
                let jweBuilder = new jose.EncryptJWT(payload);

                // Add auto IAT if enabled
                if (jweSettings.autoIat) {
                    jweBuilder = jweBuilder.setIssuedAt();
                }

                // Add auto EXP if enabled
                if (jweSettings.autoExp) {
                    const expString = getExpirationString(jweSettings.expDuration, jweSettings.expUnit);
                    jweBuilder = jweBuilder.setExpirationTime(expString);
                }

                let jwe;

                if (algorithm === 'dir') {
                    // For JWE, use dedicated JWE secret key
                    const secretKey = jweSettings.secretKey;

                    if (!secretKey || secretKey.length < 32) {
                        updateStatus('JWE requires a secret key of at least 32 characters. Please set it in JWE settings.');
                        return false;
                    }

                    // Convert string to Uint8Array
                    const key = new TextEncoder().encode(secretKey);

                    // Encrypt the JWE
                    jwe = await jweBuilder
                        .setProtectedHeader({
                            alg: 'dir',
                            enc: 'A256GCM'
                        })
                        .encrypt(key);
                } else if (algorithm === 'ECDH-ES') {
                    if (!jweSettings.publicKeyPem || jweSettings.publicKeyPem.trim() === '') {
                        updateStatus('JWE requires a recipient public key for ECDH-ES. Please set it in JWE settings.');
                        return false;
                    }

                    if (!jweSettings.publicKeyPem.includes('-----BEGIN PUBLIC KEY-----')) {
                        updateStatus('Invalid JWE public key format. Expected PEM SPKI format.');
                        return false;
                    }

                    const publicKey = await importSPKI(jweSettings.publicKeyPem, 'ECDH-ES');

                    jwe = await jweBuilder
                        .setProtectedHeader({
                            alg: 'ECDH-ES',
                            enc: 'A256GCM'
                        })
                        .encrypt(publicKey);
                } else {
                    updateStatus(`Unsupported JWE algorithm: ${algorithm}`);
                    return false;
                }

                openResultInNewTab('Encrypted JWE', jwe);

                updateStatus('JWE encrypted successfully (opened in new tab)');
                return true;
            } catch (e) {
                updateStatus(`Failed to encrypt JWE: ${e.message}`);
                return false;
            }
        }

        async function decryptJWE() {
            if (!view) {
                updateStatus('No editor available');
                return false;
            }

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            let text, from, to;

            if (hasSelection) {
                from = Math.min(selection.anchor, selection.head);
                to = Math.max(selection.anchor, selection.head);
                text = state.doc.sliceString(from, to).trim();
            } else {
                from = 0;
                to = state.doc.length;
                text = state.doc.toString().trim();
            }

            if (!text) {
                updateStatus('No JWE to decrypt');
                return false;
            }

            try {
                const algorithm = jweSettings.algorithm || 'dir';
                let decryptKey;

                if (algorithm === 'dir') {
                    const secretKey = jweSettings.secretKey;

                    if (!secretKey || secretKey.length < 32) {
                        updateStatus('JWE requires a secret key of at least 32 characters. Please set it in JWE settings.');
                        return false;
                    }

                    // Convert string to Uint8Array
                    decryptKey = new TextEncoder().encode(secretKey);
                } else if (algorithm === 'ECDH-ES') {
                    if (!jweSettings.privateKeyPem || jweSettings.privateKeyPem.trim() === '') {
                        updateStatus('JWE requires a private key for ECDH-ES decryption. Please set it in JWE settings.');
                        return false;
                    }

                    if (!jweSettings.privateKeyPem.includes('-----BEGIN PRIVATE KEY-----')) {
                        updateStatus('Invalid JWE private key format. Expected PEM PKCS#8 format.');
                        return false;
                    }

                    decryptKey = await importPKCS8(jweSettings.privateKeyPem, 'ECDH-ES');
                } else {
                    updateStatus(`Unsupported JWE algorithm: ${algorithm}`);
                    return false;
                }

                // Decrypt the JWE
                const { payload } = await jose.jwtDecrypt(text, decryptKey);

                // Format the payload as JSON
                const formattedPayload = JSON.stringify(payload, null, 2);

                // Replace content with decrypted payload
                view.dispatch({
                    changes: { from, to, insert: formattedPayload }
                });

                updateStatus('JWE decrypted successfully');
                return true;
            } catch (e) {
                if (e.code === 'ERR_JWT_EXPIRED') {
                    updateStatus('JWE decryption failed: Token has expired');
                } else if (e.code === 'ERR_JWE_DECRYPTION_FAILED') {
                    updateStatus('JWE decryption failed: Invalid key or corrupted token');
                } else {
                    updateStatus(`JWE decryption failed: ${e.message}`);
                }
                return false;
            }
        }

        // ===== Generator Functions =====
        let generatorSettings = {
            timestampFormat: 'unix_ms',
            lastRegex: 'alphanumeric',
            customRegexes: [],
            lastLength: 16
        };

        async function initGeneratorSettings() {
            const settings = await loadGeneratorSettings();
            if (settings) {
                generatorSettings = settings;
            } else {
                await saveGeneratorSettings(generatorSettings);
            }
            updateGeneratorSettingsUI();
            populateCustomRegexOptions();
        }

        async function loadGeneratorSettings() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['generatorSettings'], 'readonly');
                const store = transaction.objectStore('generatorSettings');
                const request = store.get('default');

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function saveGeneratorSettings(settings) {
            settings.id = 'default';
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['generatorSettings'], 'readwrite');
                const store = transaction.objectStore('generatorSettings');
                const request = store.put(settings);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        function updateGeneratorSettingsUI() {
            // Update timestamp format radio buttons
            const timestampRadios = document.querySelectorAll('input[name="timestamp-format"]');
            timestampRadios.forEach(radio => {
                radio.checked = radio.value === generatorSettings.timestampFormat;
            });

            // Update regex preset dropdown
            const regexPreset = document.getElementById('regex-preset');
            if (regexPreset) {
                regexPreset.value = generatorSettings.lastRegex;
            }

            // Update length input
            const lengthInput = document.getElementById('random-length');
            if (lengthInput) {
                lengthInput.value = generatorSettings.lastLength;
            }

            // Update dropdown options
            populateCustomRegexOptions();
        }

        function populateCustomRegexOptions() {
            const select = document.getElementById('regex-preset');
            if (!select) return;

            // Save current selection
            const currentValue = select.value;

            // Clear all options
            select.innerHTML = '';

            // Add predefined presets
            const presets = [
                { value: 'alpha', label: 'Letters only' },
                { value: 'numeric', label: 'Numbers only' },
                { value: 'alphanumeric', label: 'Letters + Numbers' },
                { value: 'special', label: 'Letters + Numbers + Special chars' }
            ];

            presets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.value;
                option.textContent = preset.label;
                select.appendChild(option);
            });

            // Add custom regex options
            generatorSettings.customRegexes.forEach(regex => {
                const option = document.createElement('option');
                option.value = regex.id;
                option.textContent = regex.name;
                select.appendChild(option);
            });

            // Add "Custom Regex..." option at the end
            const customOption = document.createElement('option');
            customOption.value = 'custom';
            customOption.textContent = 'Custom Regex...';
            select.appendChild(customOption);

            // Restore selection if it still exists, otherwise default to alphanumeric
            const optionExists = Array.from(select.options).some(opt => opt.value === currentValue);
            select.value = optionExists ? currentValue : 'alphanumeric';
        }

        async function addCustomRegex(name, pattern) {
            const newRegex = {
                id: crypto.randomUUID(),
                name: name,
                pattern: pattern
            };

            generatorSettings.customRegexes.unshift(newRegex);

            // Keep only last 10 custom regexes
            if (generatorSettings.customRegexes.length > 10) {
                generatorSettings.customRegexes = generatorSettings.customRegexes.slice(0, 10);
            }

            await saveGeneratorSettings(generatorSettings);
            populateCustomRegexOptions();

            return newRegex.id;
        }

        async function deleteCustomRegex(id) {
            generatorSettings.customRegexes = generatorSettings.customRegexes.filter(r => r.id !== id);
            await saveGeneratorSettings(generatorSettings);
            populateCustomRegexOptions();

            // Reset to alphanumeric preset and hide custom section
            const select = document.getElementById('regex-preset');
            if (select) {
                select.value = 'alphanumeric';
            }

            const customSection = document.getElementById('custom-regex-section');
            if (customSection) {
                customSection.style.display = 'none';
            }
        }

        function insertTextAtCursor(text) {
            if (!view) {
                updateStatus('No editor active');
                return;
            }

            const pos = view.state.selection.main.head;
            view.dispatch({
                changes: { from: pos, to: pos, insert: text },
                selection: { anchor: pos + text.length }
            });

            // Focus editor after insertion
            view.focus();
        }

        function toggleGeneratorSections(mode) {
            const timestampSection = document.querySelector('#generator-settings-modal .form-section:nth-child(1)');
            const randomSection = document.querySelector('#generator-settings-modal .form-section:nth-child(2)');

            if (mode === 'timestamp') {
                timestampSection.style.display = 'block';
                randomSection.style.display = 'none';
            } else if (mode === 'random') {
                timestampSection.style.display = 'none';
                randomSection.style.display = 'block';
            }
        }

        async function generateTimestamp() {
            const format = document.querySelector('input[name="timestamp-format"]:checked')?.value || generatorSettings.timestampFormat;

            let timestamp;
            switch (format) {
                case 'unix_ms':
                    timestamp = Date.now().toString();
                    break;
                case 'unix_s':
                    timestamp = Math.floor(Date.now() / 1000).toString();
                    break;
                case 'iso8601':
                    timestamp = new Date().toISOString();
                    break;
                default:
                    timestamp = Date.now().toString();
            }

            insertTextAtCursor(timestamp);

            // Save format preference
            generatorSettings.timestampFormat = format;
            await saveGeneratorSettings(generatorSettings);

            updateStatus(`Inserted timestamp: ${timestamp}`);
        }

        function generateUUID() {
            const uuid = crypto.randomUUID();
            insertTextAtCursor(uuid);
            updateStatus(`Inserted UUID: ${uuid}`);
        }

        async function generateRandomString() {
            try {
                const presetSelect = document.getElementById('regex-preset');
                const lengthInput = document.getElementById('random-length');
                const customNameInput = document.getElementById('custom-regex-name');
                const customPatternInput = document.getElementById('custom-regex-pattern');

                let selectedValue = presetSelect.value;
                const length = parseInt(lengthInput.value) || 16;

                let pattern;
                const presets = ['alpha', 'numeric', 'alphanumeric', 'special'];

                // Check if it's a predefined preset
                if (presets.includes(selectedValue)) {
                    pattern = REGEX_PRESETS[selectedValue];
                }
                // Check if it's "custom" (creating new)
                else if (selectedValue === 'custom') {
                    const customName = customNameInput.value.trim();
                    const customPattern = customPatternInput.value.trim();

                    if (!customName || !customPattern) {
                        updateStatus('Please enter both custom regex name and pattern');
                        return;
                    }

                    pattern = customPattern;

                    // Add new custom regex and get its ID
                    const newId = await addCustomRegex(customName, customPattern);
                    selectedValue = newId;
                }
                // Otherwise it's a custom regex ID (editing existing)
                else {
                    const customName = customNameInput.value.trim();
                    const customPattern = customPatternInput.value.trim();

                    if (!customName || !customPattern) {
                        updateStatus('Please enter both custom regex name and pattern');
                        return;
                    }

                    pattern = customPattern;

                    // Find the existing custom regex
                    const existingIndex = generatorSettings.customRegexes.findIndex(r => r.id === selectedValue);
                    if (existingIndex !== -1) {
                        // Update the existing custom regex
                        generatorSettings.customRegexes[existingIndex].name = customName;
                        generatorSettings.customRegexes[existingIndex].pattern = customPattern;
                        await saveGeneratorSettings(generatorSettings);
                        populateCustomRegexOptions();
                    }
                }

                // Generate random string using the pattern
                const fullPattern = `${pattern}{${length}}`;
                const randexp = new RandExp(fullPattern);
                const randomString = randexp.gen();

                insertTextAtCursor(randomString);

                // Save preferences
                generatorSettings.lastRegex = selectedValue;
                generatorSettings.lastLength = length;
                await saveGeneratorSettings(generatorSettings);

                updateStatus(`Inserted random string (${length} chars)`);

            } catch (error) {
                updateStatus(`Error generating random string: ${error.message}`);
                console.error('Random string generation error:', error);
            }
        }

        // String case conversion utilities
        function toPascalCase(str) {
            return str
                .replace(/[_\s-]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')
                .replace(/^(.)/, c => c.toUpperCase());
        }

        function toCamelCase(str) {
            return str
                .replace(/[_\s-]+(.)?/g, (_, c) => c ? c.toUpperCase() : '')
                .replace(/^(.)/, c => c.toLowerCase());
        }

        function toSnakeCase(str) {
            return str
                .replace(/([A-Z])/g, '_$1')
                .replace(/[_\s-]+/g, '_')
                .replace(/^_/, '')
                .toLowerCase();
        }

        function toKebabCase(str) {
            return str
                .replace(/([A-Z])/g, '-$1')
                .replace(/[_\s-]+/g, '-')
                .replace(/^-/, '')
                .toLowerCase();
        }

        function toUpperCase(str) {
            return str.toUpperCase();
        }

        function toLowerCase(str) {
            return str.toLowerCase();
        }

        // Main function to apply text transformations
        function transformText(transformFn, transformName) {
            if (!view) return false;

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            let from, to, text;

            if (hasSelection) {
                // Transform selected text
                from = Math.min(selection.anchor, selection.head);
                to = Math.max(selection.anchor, selection.head);
                text = state.doc.sliceString(from, to);
            } else {
                // Transform whole document
                from = 0;
                to = state.doc.length;
                text = state.doc.toString();
            }

            if (!text) {
                updateStatus('No text to transform');
                return false;
            }

            // Apply transformation
            const transformed = transformFn(text);

            // Replace text
            view.dispatch({
                changes: { from, to, insert: transformed }
            });

            updateStatus(`Converted to ${transformName}`);
            return true;
        }

        function getSelectedOrAllText() {
            if (!view) return null;

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            if (hasSelection) {
                return state.doc.sliceString(
                    Math.min(selection.anchor, selection.head),
                    Math.max(selection.anchor, selection.head)
                );
            }

            return state.doc.toString();
        }

        function escapeToNewTab(transformFn, transformName) {
            const text = getSelectedOrAllText();

            if (text === null) {
                updateStatus('No editor available');
                return false;
            }

            if (!text) {
                updateStatus('No text to transform');
                return false;
            }

            const transformed = transformFn(text);
            const opened = openResultInNewTab(transformName, transformed);

            if (opened) {
                updateStatus(`${transformName} opened in new tab`);
            }

            return opened;
        }

        async function unescapeToNewFile(transformFn, transformName, extension) {
            const text = getSelectedOrAllText();

            if (text === null) {
                updateStatus('No editor available');
                return false;
            }

            if (!text) {
                updateStatus('No text to transform');
                return false;
            }

            const transformed = transformFn(text);
            const baseName = await getNextUntitledName();
            const name = `${baseName}.${extension}`;

            const tempId = nextTempId--;
            tempFiles.set(tempId, {
                id: tempId,
                name,
                path: `/${name}`,
                content: transformed,
                type: 'file',
                parentId: null,
                createdAt: new Date(),
                updatedAt: new Date()
            });

            await openFile(tempId);

            isDirty = true;
            fileDirtyState.set(tempId, true);

            updateStatus(`${transformName} -> ${name}`);
            return true;
        }

        // String escape/unescape utilities
        function escapeJson(str) {
            return str
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/'/g, "\\'")
                .replace(/\r\n/g, '\\r\\n')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\t/g, '\\t')
                .replace(/\f/g, '\\f');
        }

        function unescapeJson(str) {
            const map = {
                'r': '\r',
                'n': '\n',
                't': '\t',
                'f': '\f',
                '"': '"',
                "'": "'",
                '\\': '\\'
            };

            // Only decode a single level of escapes; leave anything else untouched
            return str.replace(/\\([rntf"'\\])/g, (match, ch) => map[ch] ?? match);
        }

        function encodeURL(str) {
            return encodeURIComponent(str);
        }

        function decodeURL(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                updateStatus('Invalid URL encoding');
                return str;
            }
        }

        function encodeFullURL(str) {
            return encodeURI(str);
        }

        function decodeFullURL(str) {
            try {
                return decodeURI(str);
            } catch (e) {
                updateStatus('Invalid URL encoding');
                return str;
            }
        }

        function escapeHTML(str) {
            return str
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#x27;');
        }

        function unescapeHTML(str) {
            const entities = {
                'amp': '&',
                'lt': '<',
                'gt': '>',
                'quot': '"',
                '#x27': "'",
                '#39': "'"
            };

            // Decode a single layer of HTML entities
            return str.replace(/&(amp|lt|gt|quot|#x27|#39);/g, (match, entity) => {
                return entities[entity] ?? match;
            });
        }

        // Base64 encode/decode utilities
        function encodeBase64(str) {
            // Handle UTF-8 characters by using TextEncoder
            const bytes = new TextEncoder().encode(str);
            let binary = '';
            bytes.forEach(byte => binary += String.fromCharCode(byte));
            return btoa(binary);
        }

        function encodeBase64ToTab() {
            if (!view) {
                updateStatus('No editor available');
                return false;
            }

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            const text = hasSelection
                ? state.doc.sliceString(
                    Math.min(selection.anchor, selection.head),
                    Math.max(selection.anchor, selection.head)
                )
                : state.doc.toString();

            if (!text) {
                updateStatus('No text to encode');
                return false;
            }

            const encoded = encodeBase64(text);
            const opened = openResultInNewTab('Base64 Encoded', encoded);

            if (opened) {
                updateStatus('Base64 encoded (opened in new tab)');
            }

            return opened;
        }

        function decodeBase64Preview() {
            if (!view) {
                updateStatus('No editor available');
                return false;
            }

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            let text, from, to;

            if (hasSelection) {
                from = Math.min(selection.anchor, selection.head);
                to = Math.max(selection.anchor, selection.head);
                text = state.doc.sliceString(from, to).trim();
            } else {
                from = 0;
                to = state.doc.length;
                text = state.doc.toString().trim();
            }

            if (!text) {
                updateStatus('No text to decode');
                return false;
            }

            try {
                let dataUrl;

                // Check if it's already a data URL
                if (text.startsWith('data:')) {
                    dataUrl = text;
                } else {
                    // Try to detect MIME type from base64 content signature
                    // First, validate it's valid base64
                    const base64Data = text.replace(/\s/g, ''); // Remove whitespace
                    const decoded = atob(base64Data); // This will throw if invalid

                    // Detect MIME type from file signature (magic numbers)
                    let mimeType = 'text/plain';

                    if (decoded.startsWith('\x89PNG')) {
                        mimeType = 'image/png';
                    } else if (decoded.startsWith('\xFF\xD8\xFF')) {
                        mimeType = 'image/jpeg';
                    } else if (decoded.startsWith('GIF87a') || decoded.startsWith('GIF89a')) {
                        mimeType = 'image/gif';
                    } else if (decoded.startsWith('%PDF')) {
                        mimeType = 'application/pdf';
                    } else if (decoded.startsWith('<svg') || decoded.startsWith('<?xml')) {
                        mimeType = 'image/svg+xml';
                    } else if (decoded.startsWith('RIFF') && decoded.includes('WEBP')) {
                        mimeType = 'image/webp';
                    }

                    dataUrl = `data:${mimeType};base64,${base64Data}`;
                }

                // Convert data URL to Blob for better browser compatibility
                // Parse the data URL to extract MIME type and base64 data
                const matches = dataUrl.match(/^data:([^;]+);base64,(.+)$/);
                if (!matches) {
                    updateStatus('Invalid data URL format');
                    return false;
                }

                const mimeType = matches[1];
                const base64Data = matches[2];

                // Decode base64 to binary string
                const binaryString = atob(base64Data);

                // Convert binary string to Uint8Array
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                // Check if content is image or PDF (binary content)
                const isBinaryContent = mimeType.startsWith('image/') || mimeType === 'application/pdf';

                if (isBinaryContent) {
                    // For images and PDFs, open in new tab
                    const blob = new Blob([bytes], { type: mimeType });
                    const blobUrl = URL.createObjectURL(blob);

                    const newWindow = window.open(blobUrl, '_blank');

                    if (newWindow) {
                        updateStatus('Preview opened in new tab');
                        return true;
                    } else {
                        updateStatus('Failed to open new tab (popup blocked?)');
                        return false;
                    }
                } else {
                    // For text-based content, decode and replace in editor
                    const decodedText = new TextDecoder('utf-8').decode(bytes);

                    // Replace the base64 text with decoded text
                    view.dispatch({
                        changes: { from, to, insert: decodedText }
                    });

                    updateStatus('Decoded text');
                    return true;
                }

            } catch (e) {
                updateStatus('Invalid Base64 data');
                return false;
            }
        }

        // QR Code utilities
        async function generateQRCode() {
            if (!view) {
                updateStatus('No editor available');
                return false;
            }

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            let text;

            if (hasSelection) {
                const from = Math.min(selection.anchor, selection.head);
                const to = Math.max(selection.anchor, selection.head);
                text = state.doc.sliceString(from, to);
            } else {
                text = state.doc.toString();
            }

            if (!text) {
                updateStatus('No text to encode as QR code');
                return false;
            }

            try {
                // Generate QR code as data URL (PNG)
                const dataUrl = await QRCode.toDataURL(text, {
                    errorCorrectionLevel: 'M',
                    type: 'image/png',
                    width: 512,
                    margin: 2
                });

                // Convert data URL to Blob for better browser compatibility
                const matches = dataUrl.match(/^data:([^;]+);base64,(.+)$/);
                if (!matches) {
                    updateStatus('Failed to generate QR code');
                    return false;
                }

                const mimeType = matches[1];
                const base64Data = matches[2];

                // Decode base64 to binary string
                const binaryString = atob(base64Data);

                // Convert binary string to Uint8Array
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                // Create Blob and object URL
                const blob = new Blob([bytes], { type: mimeType });
                const blobUrl = URL.createObjectURL(blob);

                // Open in new tab
                const newWindow = window.open(blobUrl, '_blank');

                if (newWindow) {
                    updateStatus('QR code generated and opened in new tab');
                    return true;
                } else {
                    updateStatus('Failed to open new tab (popup blocked?)');
                    return false;
                }

            } catch (e) {
                updateStatus('Failed to generate QR code: ' + e.message);
                return false;
            }
        }

        async function readQRCode() {
            if (!view) {
                updateStatus('No editor available');
                return false;
            }

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            let text;

            if (hasSelection) {
                text = state.doc.sliceString(
                    Math.min(selection.anchor, selection.head),
                    Math.max(selection.anchor, selection.head)
                ).trim();
            } else {
                text = state.doc.toString().trim();
            }

            if (!text) {
                updateStatus('No base64 data to read');
                return false;
            }

            try {
                let dataUrl;

                // Check if it's already a data URL
                if (text.startsWith('data:')) {
                    dataUrl = text;
                } else {
                    // Assume it's raw base64 and try common image types
                    const base64Data = text.replace(/\s/g, '');
                    const decoded = atob(base64Data);

                    // Detect MIME type from file signature
                    let mimeType = 'image/png'; // Default to PNG for QR codes

                    if (decoded.startsWith('\x89PNG')) {
                        mimeType = 'image/png';
                    } else if (decoded.startsWith('\xFF\xD8\xFF')) {
                        mimeType = 'image/jpeg';
                    } else if (decoded.startsWith('GIF87a') || decoded.startsWith('GIF89a')) {
                        mimeType = 'image/gif';
                    }

                    dataUrl = `data:${mimeType};base64,${base64Data}`;
                }

                // Load image
                const img = new Image();

                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = dataUrl;
                });

                // Create canvas and draw image
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                // Get image data
                const imageData = ctx.getImageData(0, 0, img.width, img.height);

                // Decode QR code
                const code = jsQR(imageData.data, imageData.width, imageData.height);

                if (code) {
                    const opened = openResultInNewTab('QR Code Data', code.data);

                    if (opened) {
                        updateStatus('QR code decoded successfully (opened in new tab)');
                    }
                    return opened;
                } else {
                    updateStatus('No QR code detected in image');
                    return false;
                }

            } catch (e) {
                updateStatus('Failed to read QR code: ' + e.message);
                return false;
            }
        }

        // Minify/Format utilities
        function formatJSON(str) {
            try {
                const parsed = JSON.parse(str);
                return JSON.stringify(parsed, null, 2);
            } catch (e) {
                throw new Error('Invalid JSON syntax');
            }
        }

        function minifyJSON(str) {
            try {
                const parsed = JSON.parse(str);
                return JSON.stringify(parsed);
            } catch (e) {
                throw new Error('Invalid JSON syntax');
            }
        }

        function formatYAML(str) {
            try {
                const parsed = jsYaml.load(str);
                return jsYaml.dump(parsed, {
                    indent: 2,
                    lineWidth: 1000,
                    noRefs: true
                }).trim();
            } catch (e) {
                throw new Error('Invalid YAML syntax');
            }
        }

        function minifyYAML(str) {
            try {
                const parsed = jsYaml.load(str);
                return jsYaml.dump(parsed, {
                    flowLevel: 0,
                    lineWidth: 1000,
                    noRefs: true
                }).trim();
            } catch (e) {
                throw new Error('Invalid YAML syntax');
            }
        }

        function formatHTML(str) {
            let formatted = '';
            let indent = 0;
            const indentStr = '  ';
            const segments = [];
            let buffer = '';
            let inTag = false;
            let quoteChar = null;

            // Split by tags while respecting attribute quotes that may contain ">"
            for (let i = 0; i < str.length; i++) {
                const ch = str[i];

                if (inTag) {
                    buffer += ch;

                    if (quoteChar) {
                        if (ch === quoteChar) {
                            quoteChar = null;
                        }
                    } else if (ch === '"' || ch === "'") {
                        quoteChar = ch;
                    } else if (ch === '>') {
                        segments.push(buffer);
                        buffer = '';
                        inTag = false;
                    }
                } else {
                    if (ch === '\x3C') {
                        if (buffer) {
                            segments.push(buffer);
                        }
                        buffer = '\x3C';
                        inTag = true;
                    } else {
                        buffer += ch;
                    }
                }
            }

            if (buffer.trim()) {
                segments.push(buffer);
            }

            const tags = segments.filter(s => s.trim());

            const splitAttributes = (tagBody) => {
                const parts = [];
                let i = 0;
                const len = tagBody.length;

                while (i < len) {
                    // Skip whitespace
                    while (i < len && /\s/.test(tagBody[i])) i++;
                    if (i >= len) break;

                    // Read attribute/tag name
                    let name = '';
                    while (i < len && !/\s/.test(tagBody[i]) && tagBody[i] !== '=' && tagBody[i] !== '>') {
                        name += tagBody[i++];
                    }
                    if (!name) break;

                    // Skip whitespace between name and '='
                    while (i < len && /\s/.test(tagBody[i])) i++;

                    // Read value if present
                    let value = '';
                    if (tagBody[i] === '=') {
                        i++; // skip '='
                        while (i < len && /\s/.test(tagBody[i])) i++;

                        if (tagBody[i] === '"' || tagBody[i] === "'") {
                            const quote = tagBody[i++];
                            while (i < len && tagBody[i] !== quote) {
                                value += tagBody[i++];
                            }
                            if (tagBody[i] === quote) i++; // consume closing quote
                            value = `${quote}${value}${quote}`;
                        } else {
                            while (i < len && !/\s/.test(tagBody[i]) && tagBody[i] !== '>') {
                                value += tagBody[i++];
                            }
                        }
                    }

                    parts.push(value ? `${name}=${value}` : name);
                }

                return parts;
            };

            const formatTagWithAttributes = (tag, indentLevel) => {
                const trimmed = tag.trim();
                // Leave comments and declarations untouched
                if (trimmed.startsWith('\x3C!') || trimmed.startsWith('\x3C?')) {
                    return indentStr.repeat(indentLevel) + trimmed + '\n';
                }

                const isSelfClosing = trimmed.endsWith('/>');
                const inner = trimmed.slice(1, isSelfClosing ? -2 : -1).trim();
                if (!inner) {
                    return indentStr.repeat(indentLevel) + trimmed + '\n';
                }

                const parts = splitAttributes(inner);
                if (parts.length <= 1) {
                    return indentStr.repeat(indentLevel) + trimmed + '\n';
                }

                const [tagName, ...attrs] = parts;
                const baseIndent = indentStr.repeat(indentLevel);
                let lines = [];
                lines.push(`${baseIndent}\x3C${tagName} ${attrs[0]}`);
                for (let i = 1; i < attrs.length; i++) {
                    lines.push(`${baseIndent}${indentStr}${attrs[i]}`);
                }
                lines[lines.length - 1] += isSelfClosing ? ' />' : '>';
                return lines.join('\n') + '\n';
            };

            for (let tag of tags) {
                tag = tag.trim();

                if (tag.startsWith('\x3C!') || tag.startsWith('\x3C?')) {
                    // Comments/declarations do not affect indentation
                    formatted += indentStr.repeat(indent) + tag + '\n';
                } else if (tag.startsWith('\x3C/')) {
                    // Closing tag - decrease indent before adding
                    indent = Math.max(0, indent - 1);
                    formatted += indentStr.repeat(indent) + tag + '\n';
                } else if (tag.startsWith('\x3C') && !tag.endsWith('/>') && !tag.match(/\x3C(br|hr|img|input|meta|link)/i)) {
                    // Opening tag - add then increase indent
                    formatted += formatTagWithAttributes(tag, indent);
                    indent++;
                } else if (tag.startsWith('\x3C')) {
                    // Self-closing or void tag
                    formatted += formatTagWithAttributes(tag, indent);
                } else {
                    // Text content
                    const trimmed = tag.trim();
                    if (trimmed) {
                        formatted += indentStr.repeat(indent) + trimmed + '\n';
                    }
                }
            }

            return formatted.trim();
        }

        function minifyHTML(str) {
            return str
                // Remove comments
                .replace(/\x3C!--[\s\S]*?-->/g, '')
                // Remove whitespace between tags
                .replace(/>\s+\x3C/g, '>\x3C')
                // Remove extra whitespace
                .replace(/\s+/g, ' ')
                .trim();
        }

        function formatXML(str) {
            let formatted = '';
            let indent = 0;
            const indentStr = '  ';

            // Split by tags
            const tags = str.split(/(\x3C[^>]+>)/g).filter(s => s.trim());

            for (let tag of tags) {
                if (tag.startsWith('\x3C/')) {
                    // Closing tag
                    indent = Math.max(0, indent - 1);
                    formatted += indentStr.repeat(indent) + tag + '\n';
                } else if (tag.startsWith('\x3C?')) {
                    // XML declaration
                    formatted += tag + '\n';
                } else if (tag.startsWith('\x3C') && !tag.endsWith('/>')) {
                    // Opening tag
                    formatted += indentStr.repeat(indent) + tag + '\n';
                    indent++;
                } else if (tag.startsWith('\x3C')) {
                    // Self-closing tag
                    formatted += indentStr.repeat(indent) + tag + '\n';
                } else {
                    // Text content
                    const trimmed = tag.trim();
                    if (trimmed) {
                        formatted += indentStr.repeat(indent) + trimmed + '\n';
                    }
                }
            }

            return formatted.trim();
        }

        function minifyXML(str) {
            return str
                // Remove comments
                .replace(/\x3C!--[\s\S]*?-->/g, '')
                // Remove whitespace between tags
                .replace(/>\s+\x3C/g, '>\x3C')
                // Remove extra whitespace
                .replace(/\s+/g, ' ')
                .trim();
        }

        // Detect format type from file extension
        function detectFormatFromExtension(fileExtension) {
            if (!fileExtension) return 'none';

            const ext = fileExtension.toLowerCase();
            if (ext === '.json') return 'json';
            if (ext === '.html' || ext === '.htm') return 'html';
            if (ext === '.xml') return 'xml';
            if (ext === '.yaml' || ext === '.yml') return 'yaml';
            return 'none';
        }

        // Format content for comparison based on format type
        function formatContentForComparison(content, formatType) {
            // If 'none', return content as-is
            if (formatType === 'none') {
                return content;
            }

            // Apply the specified format
            try {
                if (formatType === 'json') {
                    return formatJSON(content);
                } else if (formatType === 'html') {
                    return formatHTML(content);
                } else if (formatType === 'xml') {
                    return formatXML(content);
                } else if (formatType === 'yaml') {
                    return formatYAML(content);
                } else {
                    return content;
                }
            } catch (e) {
                // Throw error with format information for better error message
                throw new Error(`Failed to format as ${formatType.toUpperCase()}: ${e.message}`);
            }
        }

        async function formatCode() {
            if (!view || !currentFileId) {
                updateStatus('No file is currently open');
                return false;
            }

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            let from, to, text;

            if (hasSelection) {
                from = Math.min(selection.anchor, selection.head);
                to = Math.max(selection.anchor, selection.head);
                text = state.doc.sliceString(from, to);
            } else {
                from = 0;
                to = state.doc.length;
                text = state.doc.toString();
            }

            // Detect file type
            const file = await getItem(currentFileId);
            if (!file) return false;

            let formatType;
            const ext = file.name.split('.').pop().toLowerCase();

            // Check if extension is ambiguous (.txt or no extension)
            if (isAmbiguousExtension(file.name)) {
                try {
                    // Show modal and wait for user selection
                    formatType = await showFormatTypeModal();
                    // Save the selected type for next time
                    formatSettings.lastSelectedType = formatType;
                    await saveFormatSettings(formatSettings);

                    // If the file has no extension, append the selected type
                    const nameParts = file.name.split('.');
                    if (nameParts.length === 1) {
                        const newName = `${file.name}.${formatType}`;
                        await renameItem(currentFileId, newName);

                        const language = detectLanguageFromFilename(newName);
                        updateLanguage(language);
                        renderFileTree();
                    }
                } catch (e) {
                    // User cancelled
                    return false;
                }
            } else if (ext === 'json' || ext === 'html' || ext === 'htm' || ext === 'xml' || ext === 'yaml' || ext === 'yml') {
                if (ext === 'htm') {
                    formatType = 'html';
                } else if (ext === 'yml') {
                    formatType = 'yaml';
                } else {
                    formatType = ext;
                }
            } else {
                updateStatus('Format only supports JSON, HTML, XML, and YAML files');
                return false;
            }

            try {
                const formatted = await applyFormatterByType(text, formatType, 'format');

                view.dispatch({
                    changes: { from, to, insert: formatted }
                });

                view.focus()

                updateStatus(`Formatted ${formatType.toUpperCase()}`);
                return true;
            } catch (e) {
                updateStatus(e.message || 'Format failed');
                return false;
            }
        }

        async function minifyCode() {
            if (!view || !currentFileId) {
                updateStatus('No file is currently open');
                return false;
            }

            const state = view.state;
            const selection = state.selection.main;
            const hasSelection = selection.anchor !== selection.head;

            let text;

            if (hasSelection) {
                text = state.doc.sliceString(
                    Math.min(selection.anchor, selection.head),
                    Math.max(selection.anchor, selection.head)
                );
            } else {
                text = state.doc.toString();
            }

            // Detect file type
            const file = await getItem(currentFileId);
            if (!file) return false;

            let formatType;
            const ext = file.name.split('.').pop().toLowerCase();

            // Check if extension is ambiguous (.txt or no extension)
            if (isAmbiguousExtension(file.name)) {
                try {
                    // Show modal and wait for user selection
                    formatType = await showFormatTypeModal();
                    // Save the selected type for next time
                    formatSettings.lastSelectedType = formatType;
                    await saveFormatSettings(formatSettings);
                } catch (e) {
                    // User cancelled
                    return false;
                }
            } else if (ext === 'json' || ext === 'html' || ext === 'htm' || ext === 'xml' || ext === 'yaml' || ext === 'yml') {
                if (ext === 'htm') {
                    formatType = 'html';
                } else if (ext === 'yml') {
                    formatType = 'yaml';
                } else {
                    formatType = ext;
                }
            } else {
                updateStatus('Minify only supports JSON, HTML, XML, and YAML files');
                return false;
            }

            try {
                const minified = await applyFormatterByType(text, formatType, 'minify');

                const opened = openResultInNewTab(`Minified ${formatType.toUpperCase()}`, minified);

                if (opened) {
                    updateStatus(`Minified ${formatType.toUpperCase()} (opened in new tab)`);
                }

                return opened;
            } catch (e) {
                updateStatus(e.message || 'Minify failed');
                return false;
            }
        }

        function detectLanguageFromFilename(filename) {
            const extension = filename.split('.').pop().toLowerCase();
            return extensionMap[extension] || 'plaintext';
        }

        function getFileIcon(filename) {
            const extension = filename.split('.').pop().toLowerCase();
            const iconMap = {
                'html': 'üåê',
                'htm': 'üåê',
                'json': '{ }',
                'xml': 'üìë',
                'yaml': 'üìã',
                'yml': 'üìã',
                'txt': 'üìÑ'
            };
            return iconMap[extension] || 'üìÑ';
        }

        // ===== Format Settings Management =====
        let formatSettings = {
            lastSelectedType: 'json'
        };

        async function initFormatSettings() {
            const settings = await loadFormatSettings();
            if (settings) {
                formatSettings = settings;
            } else {
                await saveFormatSettings(formatSettings);
            }
        }

        async function loadFormatSettings() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['formatSettings'], 'readonly');
                const store = transaction.objectStore('formatSettings');
                const request = store.get('default');

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function saveFormatSettings(settings) {
            settings.id = 'default';
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['formatSettings'], 'readwrite');
                const store = transaction.objectStore('formatSettings');
                const request = store.put(settings);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // ===== App Settings Management =====
        let appSettings = {
            id: 'default',
            lastOpenedFileId: null
        };

        async function initAppSettings() {
            const settings = await loadAppSettings();
            if (settings) {
                appSettings = { ...appSettings, ...settings };
            } else {
                await saveAppSettings(appSettings);
            }
        }

        async function loadAppSettings() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['appSettings'], 'readonly');
                const store = transaction.objectStore('appSettings');
                const request = store.get('default');

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function saveAppSettings(settings) {
            settings.id = 'default';
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['appSettings'], 'readwrite');
                const store = transaction.objectStore('appSettings');
                const request = store.put(settings);

                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function persistLastOpenedFile(id) {
            if (!id || id < 0) return;
            if (appSettings.lastOpenedFileId === id) return;
            appSettings.lastOpenedFileId = id;
            await saveAppSettings(appSettings);
        }

        function isAmbiguousExtension(filename) {
            // Check if file has no extension or is a .txt file
            const parts = filename.split('.');
            if (parts.length === 1) {
                // No extension
                return true;
            }
            const ext = parts.pop().toLowerCase();
            return ext === 'txt';
        }

        function showFormatTypeModal() {
            return new Promise((resolve, reject) => {
                const modal = document.getElementById('format-type-modal');

                // Set default selection based on last used type
                const radios = document.querySelectorAll('input[name="format-type"]');
                radios.forEach(radio => {
                    radio.checked = radio.value === formatSettings.lastSelectedType;
                });

                // Show modal
                showModal('format-type-modal');

                // Focus checked radio for keyboard handling
                setTimeout(() => {
                    const checkedRadio = document.querySelector('input[name="format-type"]:checked');
                    if (checkedRadio) checkedRadio.focus();
                }, 0);

                // Handlers
                const handleConfirm = () => {
                    const selectedRadio = document.querySelector('input[name="format-type"]:checked');
                    if (selectedRadio) {
                        resolve(selectedRadio.value);
                    }
                    cleanup();
                };

                const handleCancel = () => {
                    reject(new Error('User cancelled'));
                    cleanup();
                };

                const cleanup = () => {
                    hideModal('format-type-modal');

                    // Remove listener
                    const modalContent = modal.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.removeEventListener('keydown', keyHandler);
                    }

                    // Clear stored functions
                    modal._resolve = null;
                    modal._reject = null;
                };

                const keyHandler = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        handleConfirm();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        handleCancel();
                    }
                };

                // Attach listener to modal content
                const modalContent = modal.querySelector('.modal-content');
                modalContent.addEventListener('keydown', keyHandler);

                // Store resolve/reject functions for button handlers
                modal._resolve = handleConfirm;
                modal._reject = handleCancel;
            });
        }

        async function applyFormatterByType(text, type, operation) {
            let result;

            try {
                if (operation === 'format') {
                    if (type === 'json') {
                        result = formatJSON(text);
                    } else if (type === 'html') {
                        result = formatHTML(text);
                    } else if (type === 'xml') {
                        result = formatXML(text);
                    } else if (type === 'yaml') {
                        result = formatYAML(text);
                    }
                } else if (operation === 'minify') {
                    if (type === 'json') {
                        result = minifyJSON(text);
                    } else if (type === 'html') {
                        result = minifyHTML(text);
                    } else if (type === 'xml') {
                        result = minifyXML(text);
                    } else if (type === 'yaml') {
                        result = minifyYAML(text);
                    }
                }

                if (result === undefined) {
                    throw new Error(`${operation === 'format' ? 'Format' : 'Minify'} only supports JSON, HTML, XML, and YAML files`);
                }

                return result;
            } catch (e) {
                if (e?.message?.startsWith('Format') || e?.message?.startsWith('Minify')) {
                    throw e;
                }
                throw new Error(`Invalid ${type.toUpperCase()} syntax: ${e.message}`);
            }
        }

        // ===== Cursor Position Management =====
        function getCurrentCursorPosition() {
            if (!view) return null;
            const pos = view.state.selection.main.head;
            return pos;
        }

        async function saveCursorPosition(fileId) {
            if (!fileId || !view) return;
            const cursorPosition = getCurrentCursorPosition();
            await updateFile(fileId, { cursorPosition });
        }

        function restoreCursorPosition(position) {
            if (!view || position === null || position === undefined) return;

            // Ensure position is within document bounds
            const docLength = view.state.doc.length;
            const safePosition = Math.min(position, docLength);

            view.dispatch({
                selection: { anchor: safePosition, head: safePosition },
                scrollIntoView: true
            });
        }

        // ===== Balance Inward/Outward Commands =====

        // Helper function to find matching bracket
        // Optimized: accepts optional cached document string to avoid repeated sliceString calls
        function findMatchingBracket(doc, startPos, direction, docStr = null) {
            const openBrackets = '([{';
            const closeBrackets = ')]}';
            const bracketPairs = { '(': ')', '[': ']', '{': '}', ')': '(', ']': '[', '}': '{' };

            // Cache document string if not provided (for performance)
            if (!docStr) {
                docStr = doc.sliceString(0, doc.length);
            }

            // Get character at start position - use direct indexing (much faster)
            const startChar = docStr[startPos];
            if (!bracketPairs[startChar]) return -1;

            const isOpen = openBrackets.includes(startChar);
            const targetChar = bracketPairs[startChar];

            let depth = 1;
            let pos = startPos + direction;

            // Use direct string indexing instead of repeated sliceString calls
            while (pos >= 0 && pos < docStr.length) {
                const char = docStr[pos];

                if (char === startChar) {
                    depth++;
                } else if (char === targetChar) {
                    depth--;
                    if (depth === 0) {
                        return pos;
                    }
                }

                pos += direction;
            }

            return -1;
        }

        // Helper function to find matching quote
        // Optimized: uses cached string and improved escape detection
        function findMatchingQuote(doc, startPos, docStr = null) {
            // Cache document string if not provided (for performance)
            if (!docStr) {
                docStr = doc.sliceString(0, doc.length);
            }

            const quoteChar = docStr[startPos];
            if (quoteChar !== '"' && quoteChar !== "'") return -1;

            // Helper to count consecutive backslashes before a position
            function countBackslashes(str, pos) {
                let count = 0;
                let i = pos - 1;
                while (i >= 0 && str[i] === '\\') {
                    count++;
                    i--;
                }
                return count;
            }

            // A quote is escaped if preceded by odd number of backslashes
            function isEscaped(str, pos) {
                return countBackslashes(str, pos) % 2 === 1;
            }

            // Count how many unescaped quotes of this type appear before startPos
            // Optimized: use direct string indexing instead of sliceString
            let quoteCount = 0;
            for (let pos = 0; pos < startPos; pos++) {
                if (docStr[pos] === quoteChar && !isEscaped(docStr, pos)) {
                    quoteCount++;
                }
            }

            // If even number of quotes before us, we're an opening quote (search forward)
            // If odd number, we're a closing quote (search backward)
            const isOpening = quoteCount % 2 === 0;
            const direction = isOpening ? 1 : -1;
            let pos = startPos + direction;

            // Search for matching unescaped quote - use direct indexing
            while (pos >= 0 && pos < docStr.length) {
                if (docStr[pos] === quoteChar && !isEscaped(docStr, pos)) {
                    return pos;
                }
                pos += direction;
            }

            return -1;
        }

        // Find the innermost delimiter pair (brackets or quotes) surrounding a position
        // Optimized: caches document string, limits search radius for performance
        function findInnerDelimiters(doc, pos, maxSearchRadius = 50000) {
            let bestResult = null;
            let smallestRange = Infinity;

            // Cache document string once for performance
            const docStr = doc.sliceString(0, doc.length);

            // Limit search radius to prevent performance issues with very large documents
            const searchStart = Math.max(0, pos - maxSearchRadius);

            // Search backwards for opening brackets and quotes
            for (let searchPos = pos - 1; searchPos >= searchStart; searchPos--) {
                const char = docStr[searchPos];  // Use direct indexing

                let closePos = -1;

                if ('([{'.includes(char)) {
                    // Found opening bracket, find its match
                    // Pass cached string to avoid re-caching
                    closePos = findMatchingBracket(doc, searchPos, 1, docStr);
                } else if ('"\''.includes(char)) {
                    // Found quote, find its match
                    // Pass cached string to avoid re-caching
                    closePos = findMatchingQuote(doc, searchPos, docStr);
                }

                if (closePos > pos) {
                    // This delimiter pair contains our position
                    const range = closePos - searchPos;
                    if (range < smallestRange) {
                        smallestRange = range;
                        bestResult = { open: searchPos, close: closePos };
                    }
                }
            }

            return bestResult;
        }

        function balanceInward() {
            if (!view) return false;

            const state = view.state;
            const pos = state.selection.main.head;
            const doc = state.doc;

            // Find innermost delimiter pair containing cursor
            const delimiters = findInnerDelimiters(doc, pos);

            if (delimiters) {
                // Select content inside delimiters (excluding the delimiter characters)
                const from = delimiters.open + 1;
                const to = delimiters.close;

                if (from < to) {
                    view.dispatch({
                        selection: { anchor: from, head: to }
                    });
                    view.focus();
                    return true;
                }
            }

            return false;
        }

        function balanceOutward() {
            if (!view) return false;

            const state = view.state;
            const selection = state.selection.main;
            const doc = state.doc;

            // Get current selection range
            const currentFrom = Math.min(selection.anchor, selection.head);
            const currentTo = Math.max(selection.anchor, selection.head);

            // Search for delimiter pair that contains current selection but is larger
            let bestResult = null;
            let smallestRange = Infinity;

            // Cache document string once for performance (optimized)
            const docStr = doc.sliceString(0, doc.length);

            // Limit search radius to prevent performance issues (default 50,000 chars)
            const maxSearchRadius = 50000;
            const searchStart = Math.max(0, currentFrom - maxSearchRadius);

            for (let searchPos = currentFrom - 1; searchPos >= searchStart; searchPos--) {
                const char = docStr[searchPos];  // Use direct indexing (optimized)

                let closePos = -1;

                if ('([{'.includes(char)) {
                    // Pass cached string to avoid re-caching (optimized)
                    closePos = findMatchingBracket(doc, searchPos, 1, docStr);
                } else if ('"\''.includes(char)) {
                    // Pass cached string to avoid re-caching (optimized)
                    closePos = findMatchingQuote(doc, searchPos, docStr);
                }

                if (closePos > currentTo) {
                    // This delimiter pair contains our current selection
                    const range = closePos - searchPos;
                    if (range < smallestRange) {
                        smallestRange = range;
                        bestResult = { open: searchPos, close: closePos };
                    }
                }
            }

            if (bestResult) {
                // Select the outer delimiter pair (including delimiters)
                view.dispatch({
                    selection: { anchor: bestResult.open, head: bestResult.close + 1 }
                });
                view.focus();
                return true;
            }

            return false;
        }

        // ===== Context Menu =====
        function createContextMenu(x, y, options) {
            // Remove any existing context menu
            const existing = document.querySelector('.custom-context-menu');
            if (existing) existing.remove();

            const menu = document.createElement('div');
            menu.className = 'custom-context-menu';
            menu.style.position = 'fixed';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.background = '#252526';
            menu.style.border = '1px solid #3e3e42';
            menu.style.borderRadius = '4px';
            menu.style.padding = '4px 0';
            menu.style.zIndex = '10000';
            menu.style.minWidth = '180px';
            menu.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';

            options.forEach(option => {
                const item = document.createElement('div');
                item.className = 'context-menu-item';
                item.textContent = option.label;
                item.style.padding = '6px 12px';
                item.style.cursor = option.disabled ? 'default' : 'pointer';
                item.style.color = option.disabled ? '#666' : '#cccccc';
                item.style.fontSize = '13px';

                if (!option.disabled) {
                    item.addEventListener('mouseenter', () => {
                        item.style.background = '#2a2d2e';
                    });
                    item.addEventListener('mouseleave', () => {
                        item.style.background = 'transparent';
                    });
                    item.addEventListener('click', () => {
                        option.action();
                        menu.remove();
                    });
                }

                menu.appendChild(item);
            });

            document.body.appendChild(menu);

            // Close menu on click outside
            const closeHandler = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeHandler);
                }
            };
            setTimeout(() => {
                document.addEventListener('click', closeHandler);
            }, 0);

            // Adjust position if menu goes off screen
            const rect = menu.getBoundingClientRect();
            if (rect.right > window.innerWidth) {
                menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
            }
            if (rect.bottom > window.innerHeight) {
                menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
            }
        }

        function showEditorContextMenu(event) {
            event.preventDefault();

            // Check if text is selected
            const state = view?.state;
            const selection = state?.selection.main;
            const hasSelection = selection && selection.anchor !== selection.head;

            const options = [
                {
                    label: 'Balance Inward',
                    disabled: !view,
                    action: () => {
                        const success = balanceInward();
                        if (success) {
                            updateStatus('Selected inner content');
                        } else {
                            updateStatus('No inner selection found');
                        }
                    }
                },
                {
                    label: 'Balance Outward',
                    disabled: !view,
                    action: () => {
                        const success = balanceOutward();
                        if (success) {
                            updateStatus('Expanded selection outward');
                        } else {
                            updateStatus('No outer selection found');
                        }
                    }
                },
                {
                    label: 'Extract JSON Subtree',
                    disabled: !view || !currentFileId,
                    action: async () => {
                        await extractJsonSubtree();
                    }
                }
            ];

            createContextMenu(event.clientX, event.clientY, options);
        }

        // ===== File Operations =====
        async function openFileInPane(id, pane) {
            const currentPaneFileId = pane === 'left' ? leftFileId : rightFileId;
            if (currentPaneFileId && currentPaneFileId !== id) {
                saveDraftContent(currentPaneFileId);
                await saveCursorPosition(currentPaneFileId);
            }

            const file = await getItem(id);
            if (!file || file.type !== 'file') return;

            isLoading = true;

            const language = detectLanguageFromFilename(file.name);
            const content = draftContent.has(file.id) ? draftContent.get(file.id) : file.content;

            if (isSplitEditor) {
                createPaneEditor(pane, file.id, content, language);
                updatePaneTitle(pane, file);
            } else {
                createSingleEditor(content, language, currentTheme, false, file.id);
            }

            setActivePane(pane);
            await persistLastOpenedFile(currentFileId);

            isDirty = fileDirtyState.get(file.id) ?? false;
            isLoading = false;

            if (file.cursorPosition !== undefined) {
                restoreCursorPosition(file.cursorPosition);
            }

            if (view) {
                view.focus();
            }

            renderFileTree();
            updateStatus(`Opened ${file.name}`);
        }

        async function openFile(id, paneOverride = null) {
            const pane = isSplitEditor ? (paneOverride || activePane) : 'left';
            await openFileInPane(id, pane);
        }

        async function saveCurrentFile() {
            const file = await getItem(currentFileId);
            if (!file) return;

            const content = view.state.doc.toString();
            const isTemporary = currentFileId < 0;

            // If file is Untitled, show rename modal
            // Match "Untitled", "Untitled (N)", "Untitled N", and any with extensions
            const nameWithoutExt = file.name.replace(/\.[^.]+$/, '');
            if (nameWithoutExt.match(/^Untitled(\s\(?\d+\)?)?$/)) {
                showRenameModal('rename-file', file.name, async (newName) => {
                    if (isTemporary) {
                        // Convert temporary file to permanent
                        const tempId = currentFileId;
                        const permanentId = await createFile(newName, content);

                        // Remove from temporary storage
                        tempFiles.delete(tempId);
                        fileDirtyState.delete(tempId);
                        draftContent.delete(tempId);

                        // Update current file ID
                        currentFileId = permanentId;
                        if (isSplitEditor) {
                            if (activePane === 'left') {
                                leftFileId = permanentId;
                            } else {
                                rightFileId = permanentId;
                            }
                        } else {
                            leftFileId = permanentId;
                        }
                        await persistLastOpenedFile(currentFileId);
                    } else {
                        // Normal rename and update
                        await renameItem(currentFileId, newName);
                        await updateFile(currentFileId, { content });
                    }

                    if (isSplitEditor) {
                        const titleEl = document.getElementById(`pane-${activePane}-title`);
                        if (titleEl) {
                            titleEl.textContent = newName;
                        }
                    }

                    // Update language based on new name
                    const language = detectLanguageFromFilename(newName);
                    updateLanguage(language);

                    // Reset dirty state after save and clear draft
                    isDirty = false;
                    clearDraft(currentFileId);

                    renderFileTree();
                    updateStatus(`Saved ${newName}`);
                    if (view) {
                        view.focus();
                    }
                });
                return;
            }

                if (isTemporary) {
                    // Convert temporary file to permanent (non-Untitled case)
                    const tempId = currentFileId;
                    const permanentId = await createFile(file.name, content);

                    // Remove from temporary storage
                    tempFiles.delete(tempId);
                    fileDirtyState.delete(tempId);
                    draftContent.delete(tempId);

                    // Update current file ID
                    currentFileId = permanentId;
                    if (isSplitEditor) {
                        if (activePane === 'left') {
                            leftFileId = permanentId;
                        } else {
                            rightFileId = permanentId;
                        }
                    } else {
                        leftFileId = permanentId;
                    }
                    await persistLastOpenedFile(currentFileId);
                } else {
                // Normal update for existing file
                await updateFile(currentFileId, { content });
            }

            // Reset dirty state after save and clear draft
            isDirty = false;
            clearDraft(currentFileId);

            // Re-render file tree for clean dirty step
            renderFileTree();
            updateStatus(`Saved ${file.name}`);
        }

        async function createNewFile() {
            // Generate filename (plain text by default)
            const baseName = await getNextUntitledName();
            const name = baseName;

            // All new files start empty
            const content = '';

            // Create temporary file (not saved to IndexedDB yet)
            const tempId = nextTempId--;
            tempFiles.set(tempId, {
                id: tempId,
                name: name,
                path: `/${name}`,
                content: content,
                type: 'file',
                parentId: null,
                createdAt: new Date(),
                updatedAt: new Date()
            });

            // Mark new file as dirty (unsaved)
            await openFile(tempId);
            isDirty = true;
            fileDirtyState.set(tempId, true);
        }

        // ===== UI Rendering =====
        async function handleRename(item) {
            showRenameModal('rename', item.name, async (newName) => {
                await renameItem(item.id, newName);

                if (item.id === currentFileId) {
                    const language = detectLanguageFromFilename(newName);
                    updateLanguage(language);
                }
                renderFileTree();
                updateStatus(`Renamed to ${newName}`);
            });
        }

        function showInlineConfirm(actionsContainer, deleteBtn, item) {
            // Hide delete button temporarily
            deleteBtn.style.display = 'none';

            // Create confirm button
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = '‚úì';
            confirmBtn.title = 'Confirm Delete';
            confirmBtn.className = 'confirm';
            confirmBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                await handleDelete(item);
            });

            // Create cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = '‚úï';
            cancelBtn.title = 'Cancel';
            cancelBtn.className = 'cancel';
            cancelBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                restoreDeleteButton();
            });

            // Add buttons
            actionsContainer.appendChild(cancelBtn);
            actionsContainer.appendChild(confirmBtn);

            // Auto-focus to make it clear something changed
            confirmBtn.focus();

            // Helper to restore original state
            const restoreDeleteButton = () => {
                confirmBtn.remove();
                cancelBtn.remove();
                deleteBtn.style.display = '';
            };

            // Click outside to cancel
            const clickOutsideHandler = (e) => {
                if (!actionsContainer.contains(e.target)) {
                    restoreDeleteButton();
                    document.removeEventListener('click', clickOutsideHandler);
                }
            };
            setTimeout(() => {
                document.addEventListener('click', clickOutsideHandler);
            }, 0);
        }

        async function handleDelete(item) {
            const wasCurrentFile = item.id === currentFileId;

            // If deleting a folder, collect all child IDs that will be deleted
            let idsToDelete = [item.id];
            if (item.type === 'folder') {
                const items = await getAllItems();
                const findChildren = (parentId) => {
                    items.forEach(i => {
                        if (i.parentId === parentId) {
                            idsToDelete.push(i.id);
                            if (i.type === 'folder') {
                                findChildren(i.id);
                            }
                        }
                    });
                };
                findChildren(item.id);
            }

            await deleteItem(item.id);

            if (appSettings.lastOpenedFileId && idsToDelete.includes(appSettings.lastOpenedFileId)) {
                appSettings.lastOpenedFileId = null;
                await saveAppSettings(appSettings);
            }

            // Clear drafts for all deleted files (including children if folder)
            idsToDelete.forEach(id => clearDraft(id));

            if (wasCurrentFile) {
                currentFileId = null;
                isDirty = false;
                createSingleEditor('', 'plaintext', currentTheme, false, null);
            }

            renderFileTree();
            updateStatus(`Deleted ${item.name}`);
        }

        async function handleDrop(draggedId, targetFolderId, targetFolderName) {
            if (!draggedId) return false;

            // Don't move if dropping on itself
            if (draggedId === targetFolderId) return false;

            const success = await moveItem(draggedId, targetFolderId);
            if (success) {
                await renderFileTree();
                const draggedItem = await getItem(draggedId);
                const destination = targetFolderName || 'root';
                updateStatus(`Moved ${draggedItem.name} to ${destination}`);
                return true;
            } else {
                updateStatus('Cannot move item here');
                return false;
            }
        }

        // ===== File Comparison Functions =====

        function renderComparisonView(applyFormat = false) {
            if (!comparisonState) return false;

            const shouldFormat = applyFormat && comparisonState.canFormat && comparisonState.formatType !== 'none';
            let leftContent = comparisonState.left.content;
            let rightContent = comparisonState.right.content;
            let statusMessage = null;

            if (shouldFormat) {
                try {
                    leftContent = formatContentForComparison(leftContent, comparisonState.formatType);
                    rightContent = formatContentForComparison(rightContent, comparisonState.formatType);
                    comparisonFormatEnabled = true;
                } catch (e) {
                    comparisonFormatEnabled = false;
                    const toggle = document.getElementById('comparison-format-toggle');
                    if (toggle) toggle.checked = false;
                    statusMessage = 'Formatting failed; showing unformatted content';
                    console.error('Comparison formatting error:', e);
                    leftContent = comparisonState.left.content;
                    rightContent = comparisonState.right.content;
                }
            } else {
                comparisonFormatEnabled = false;
            }

            const leftExtensions = [
                basicSetup,
                search({ top: true }),
                highlightSelectionMatches(),
                EditorView.editable.of(false)
            ];

            const rightExtensions = [
                basicSetup,
                search({ top: true }),
                highlightSelectionMatches(),
                EditorView.editable.of(false)
            ];

            const leftLangExtension = languageMap[comparisonState.left.lang];
            const rightLangExtension = languageMap[comparisonState.right.lang];

            const maybeAddExtensions = (extProvider, target) => {
                if (!extProvider) return;
                const extValue = extProvider();
                if (Array.isArray(extValue)) {
                    target.push(...extValue);
                } else {
                    target.push(extValue);
                }
            };

            maybeAddExtensions(leftLangExtension, leftExtensions);
            maybeAddExtensions(rightLangExtension, rightExtensions);

            if (currentTheme === 'dark') {
                leftExtensions.push(oneDark);
                rightExtensions.push(oneDark);
            }

            const mainContainer = document.getElementById('editor-content');
            mainContainer.innerHTML = '';

            if (view) {
                view.destroy();
            }
            destroyPaneEditors();
            view = null;

            if (mergeView) {
                mergeView.destroy();
                mergeView = null;
            }

            if (comparisonViewMode === 'inline') {
                const inlineExtensions = [
                    basicSetup,
                    search({ top: true }),
                    highlightSelectionMatches(),
                    EditorView.editable.of(false),
                    unifiedMergeView({ original: rightContent })
                ];

                const inlineLangExtension = languageMap[comparisonState.left.lang];
                if (inlineLangExtension) {
                    const extValue = inlineLangExtension();
                    if (Array.isArray(extValue)) {
                        inlineExtensions.push(...extValue);
                    } else {
                        inlineExtensions.push(extValue);
                    }
                }

                if (currentTheme === 'dark') {
                    inlineExtensions.push(oneDark);
                }

                view = new EditorView({
                    doc: leftContent,
                    extensions: inlineExtensions,
                    parent: mainContainer
                });
            } else {
                mergeView = new MergeView({
                    a: {
                        doc: leftContent,
                        extensions: leftExtensions
                    },
                    b: {
                        doc: rightContent,
                        extensions: rightExtensions
                    },
                    parent: mainContainer
                });
            }

            const formatLabel = comparisonFormatEnabled && comparisonState.formatType !== 'none'
                ? `${comparisonState.formatType.toUpperCase()}`
                : 'Unformatted';
            const viewLabel = comparisonViewMode === 'inline' ? 'Inline' : 'Side-by-side';
            const finalStatus = statusMessage || `Comparing ${comparisonState.left.name} vs ${comparisonState.right.name} (${formatLabel}, ${viewLabel})`;
            updateStatus(finalStatus);
            return comparisonFormatEnabled || !shouldFormat;
        }

        async function compareFileWithActive(fileItem) {
            if (!currentFileId) {
                updateStatus('Open a file before comparing');
                return;
            }

            if (fileItem.id === currentFileId) {
                updateStatus('Choose a different file to compare');
                return;
            }

            disableSplitViewForComparison();

            const [activeFile, targetFile] = await Promise.all([
                getItem(currentFileId),
                getItem(fileItem.id)
            ]);

            if (!activeFile || !targetFile) {
                updateStatus('Error loading files for comparison');
                return;
            }

            comparisonFormatEnabled = false;

            isComparing = true;
            const editorContainer = document.getElementById('editor-container');
            editorContainer.classList.add("split-view");

            document.getElementById('filename-main').textContent = activeFile.name;
            document.getElementById('filename-compare').textContent = targetFile.name;

            const ext1 = activeFile.name.includes('.') ? activeFile.name.split('.').pop() : '';
            const fileExt1 = ext1 ? '.' + ext1 : '';
            const lang1 = ext1 ? (extensionMap[ext1] || 'plaintext') : 'plaintext';

            const ext2 = targetFile.name.includes('.') ? targetFile.name.split('.').pop() : '';
            const fileExt2 = ext2 ? '.' + ext2 : '';
            const lang2 = ext2 ? (extensionMap[ext2] || 'plaintext') : 'plaintext';

            const leftFormat = fileExt1 ? detectFormatFromExtension(fileExt1) : 'none';
            const rightFormat = fileExt2 ? detectFormatFromExtension(fileExt2) : 'none';
            const canFormat = leftFormat !== 'none' && leftFormat === rightFormat;

            const baseLeftContent = draftContent.has(activeFile.id) ? draftContent.get(activeFile.id) : activeFile.content || '';
            const baseRightContent = draftContent.has(targetFile.id) ? draftContent.get(targetFile.id) : targetFile.content || '';

            comparisonState = {
                type: 'file-to-file',
                canFormat,
                formatType: canFormat ? leftFormat : 'none',
                left: {
                    id: activeFile.id,
                    name: activeFile.name,
                    content: baseLeftContent,
                    lang: lang1
                },
                right: {
                    id: targetFile.id,
                    name: targetFile.name,
                    content: baseRightContent,
                    lang: lang2
                }
            };

            const toggleContainer = document.getElementById('format-toggle-container');
            const toggle = document.getElementById('comparison-format-toggle');
            const toggleText = document.getElementById('comparison-format-text');
            const viewContainer = document.getElementById('view-mode-container');
            const viewSelect = document.getElementById('comparison-view-mode');

            if (toggle) toggle.checked = false;
            if (toggleContainer) toggleContainer.style.display = canFormat ? 'flex' : 'none';
            if (toggleText) {
                toggleText.textContent = canFormat ? `Format as ${leftFormat.toUpperCase()}` : 'Format view';
            }
            if (viewContainer) viewContainer.style.display = 'flex';
            if (viewSelect) viewSelect.value = comparisonViewMode;

            document.getElementById('close-comparison-btn').style.display = 'block';

            const success = renderComparisonView(false);
            if (!success) {
                updateStatus('Error rendering comparison');
            }
        }

        function closeComparison() {
            if (!isComparing) return;

            isComparing = false;

            // Hide format toggle and reset format
            const formatToggle = document.getElementById('format-toggle-container');
            const formatCheckbox = document.getElementById('comparison-format-toggle');
            if (formatToggle) formatToggle.style.display = 'none';
            if (formatCheckbox) formatCheckbox.checked = false;
            comparisonFormatEnabled = false;
            const viewContainer = document.getElementById('view-mode-container');
            if (viewContainer) viewContainer.style.display = 'none';

            // Reset comparison state tracking
            comparisonState = null;

            // Destroy MergeView
            if (mergeView) {
                mergeView.destroy();
                mergeView = null;
            }

            // Hide split view
            const editorContainer = document.getElementById('editor-container');
            editorContainer.classList.remove("split-view")


            // Clear container contents
            const mainContainer = document.getElementById('editor-content');
            mainContainer.innerHTML = '';

            // Restore current file if any
            if (currentFileId) {
                openFile(currentFileId);
            } else {
                // Create empty editor
                createSingleEditor('', 'plaintext', currentTheme, false, null);
            }

            updateStatus('Closed comparison view');
        }

        async function compareFileWithClipboard(fileItem) {
            try {
                const clipboardText = await navigator.clipboard.readText();

                if (!clipboardText || clipboardText.trim() === '') {
                    updateStatus('Clipboard is empty');
                    return;
                }

                disableSplitViewForComparison();

                const fileData = await getItem(fileItem.id);
                if (!fileData) {
                    updateStatus('Error loading file');
                    return;
                }

                comparisonFormatEnabled = false;

                isComparing = true;
                const editorContainer = document.getElementById('editor-container');
                editorContainer.classList.add("split-view");

                document.getElementById('filename-main').textContent = fileData.name;
                document.getElementById('filename-compare').textContent = 'Clipboard Content';

                const ext = fileData.name.includes('.') ? fileData.name.split('.').pop() : '';
                const fileExt = ext ? '.' + ext : '';
                const lang = ext ? (extensionMap[ext] || 'plaintext') : 'plaintext';

                const formatType = fileExt ? detectFormatFromExtension(fileExt) : 'none';
                const canFormat = formatType !== 'none';

                comparisonState = {
                    type: 'file-to-clipboard',
                    canFormat,
                    formatType: canFormat ? formatType : 'none',
                    left: {
                        id: fileData.id,
                        name: fileData.name,
                        content: draftContent.has(fileData.id) ? draftContent.get(fileData.id) : fileData.content || '',
                        lang: lang
                    },
                    right: {
                        name: 'Clipboard Content',
                        content: clipboardText,
                        lang: lang
                    }
                };

            const toggleContainer = document.getElementById('format-toggle-container');
            const toggle = document.getElementById('comparison-format-toggle');
            const toggleText = document.getElementById('comparison-format-text');
            const viewContainer = document.getElementById('view-mode-container');
            const viewSelect = document.getElementById('comparison-view-mode');

            if (toggle) toggle.checked = false;
            if (toggleContainer) toggleContainer.style.display = canFormat ? 'flex' : 'none';
            if (toggleText) {
                toggleText.textContent = canFormat ? `Format as ${formatType.toUpperCase()}` : 'Format view';
            }
            if (viewContainer) viewContainer.style.display = 'flex';
            if (viewSelect) viewSelect.value = comparisonViewMode;

                document.getElementById('close-comparison-btn').style.display = 'block';

                const success = renderComparisonView(false);
                if (!success) {
                    updateStatus('Error rendering comparison');
                }
            } catch (error) {
                if (error.name === 'NotAllowedError') {
                    updateStatus('Clipboard access denied. Please grant permission.');
                } else {
                    updateStatus(`Error: ${error.message}`);
                }
                console.error('Clipboard comparison error:', error);
            }
        }

        function showFileTreeContextMenu(event, fileItem) {
            event.preventDefault();
            event.stopPropagation();

            // Only show context menu for files, not folders
            if (fileItem.type !== 'file') return;

            const options = [];

            if (isSplitEditor) {
                options.push(
                    {
                        label: 'Open in Left Pane',
                        disabled: false,
                        action: async () => {
                            await openFile(fileItem.id, 'left');
                        }
                    },
                    {
                        label: 'Open in Right Pane',
                        disabled: false,
                        action: async () => {
                            await openFile(fileItem.id, 'right');
                        }
                    }
                );
            } else {
                options.push({
                    label: 'Open in Split (Right)',
                    disabled: false,
                    action: async () => {
                        await setSplitView(true);
                        await openFile(fileItem.id, 'right');
                    }
                });
            }

            options.push(
                {
                    label: 'Compare with Active File',
                    disabled: false,
                    action: async () => {
                        await compareFileWithActive(fileItem);
                    }
                },
                {
                    label: 'Compare with Clipboard',
                    disabled: false,
                    action: async () => {
                        await compareFileWithClipboard(fileItem);
                    }
                }
            );

            createContextMenu(event.clientX, event.clientY, options);
        }

        async function renderFileTree() {
            const fileTree = document.getElementById('file-tree');
            // Clear all tree items - this destroys old DOM elements and their event listeners
            // Event listeners on destroyed elements are automatically garbage collected, no removeEventListener needed
            fileTree.innerHTML = '';

            const items = await getAllItems();
            const rootItems = items.filter(item => !item.parentId).sort((a, b) => {
                if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
                return a.name.localeCompare(b.name);
            });

            const renderItem = (item, indent = 0) => {
                const div = document.createElement('div');
                div.className = `tree-item indent-${indent}`;
                if (item.type === 'folder') div.classList.add('folder');
                if (item.id === currentFileId) div.classList.add('active');
                if (isSplitEditor) {
                    const isLeft = item.id === leftFileId;
                    const isRight = item.id === rightFileId;
                    if ((isLeft || isRight) && item.id !== currentFileId) {
                        div.classList.add('active-secondary');
                    }
                }
                if (fileDirtyState.get(item.id)) div.classList.add('dirty');

                const icon = document.createElement('span');
                icon.className = 'icon';
                icon.textContent = item.type === 'folder' ? 'üìÅ' : getFileIcon(item.name);

                const name = document.createElement('span');
                name.className = 'name';
                name.textContent = item.name;
                name.title = item.name; // Show full name on hover

                // Create action buttons
                const actions = document.createElement('div');
                actions.className = 'actions';

                const renameBtn = document.createElement('button');
                renameBtn.textContent = '‚úèÔ∏è';
                renameBtn.title = 'Rename';
                renameBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleRename(item);
                });

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'üóëÔ∏è';
                deleteBtn.title = 'Delete';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showInlineConfirm(actions, deleteBtn, item);
                });

                actions.appendChild(renameBtn);
                actions.appendChild(deleteBtn);

                div.appendChild(icon);
                div.appendChild(name);
                div.appendChild(actions);

                // Make item draggable
                div.setAttribute('draggable', 'true');
                div.setAttribute('data-item-id', item.id);

                // Drag start - store the dragged item ID
                div.addEventListener('dragstart', (e) => {
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', item.id);
                    div.classList.add('dragging');
                });

                // Drag end - cleanup
                div.addEventListener('dragend', (e) => {
                    div.classList.remove('dragging');
                    document.querySelectorAll('.drag-over').forEach(el => {
                        el.classList.remove('drag-over');
                    });
                });

                // Only folders can be drop targets
                if (item.type === 'folder') {
                    div.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.dataTransfer.dropEffect = 'move';
                    });

                    div.addEventListener('dragenter', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const draggedId = parseInt(e.dataTransfer.getData('text/plain') || '-1');
                        // Don't highlight if dragging the folder itself
                        if (draggedId !== item.id) {
                            div.classList.add('drag-over');
                        }
                    });

                    div.addEventListener('dragleave', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        // Only remove highlight if we're actually leaving this element
                        if (e.target === div && !div.contains(e.relatedTarget)) {
                            div.classList.remove('drag-over');
                        }
                    });

                    div.addEventListener('drop', async (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        div.classList.remove('drag-over');

                        const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
                        await handleDrop(draggedId, item.id, item.name);
                    });
                }

                if (item.type === 'file') {
                    name.addEventListener('click', () => openFile(item.id));
                    // Add right-click context menu for file comparison
                    div.addEventListener('contextmenu', (e) => showFileTreeContextMenu(e, item));
                }

                fileTree.appendChild(div);

                if (item.type === 'folder') {
                    const children = items.filter(i => i.parentId === item.id).sort((a, b) => {
                        if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
                        return a.name.localeCompare(b.name);
                    });
                    children.forEach(child => renderItem(child, indent + 1));
                }
            };

            rootItems.forEach(item => renderItem(item));
        }

        // Initialize root drop zone (called once during initialization)
        function initFileTreeDropZone() {
            const fileTree = document.getElementById('file-tree');

            // Add drop zone for root level (to move items out of folders)
            fileTree.addEventListener('dragover', (e) => {
                // Only handle drops on the file tree background, not on items
                if (e.target === fileTree) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                }
            });

            fileTree.addEventListener('drop', async (e) => {
                // Only handle drops on the file tree background
                if (e.target === fileTree) {
                    e.preventDefault();
                    const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
                    await handleDrop(draggedId, null, 'root');
                }
            });
        }

        // ===== Modal Functions =====
        function showModal(modalId) {
            document.getElementById(modalId).classList.add('show');
        }

        function hideModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }

        function showRenameModal(mode, currentName, onConfirm) {
            const modal = document.getElementById('rename-modal');
            const input = document.getElementById('modal-input');
            const title = document.getElementById('modal-title');

            title.textContent = mode === 'new-file' ? 'New File' :
                mode === 'new-folder' ? 'New Folder' : 'Rename';
            input.value = currentName;

            showModal('rename-modal');
            input.focus();
            input.select();

            const confirm = async () => {
                const newName = input.value.trim();
                if (newName) {
                    await onConfirm(newName);
                }
                hideModal('rename-modal');
                cleanup();
            };

            const cancel = () => {
                hideModal('rename-modal');
                cleanup();
            };

            const cleanup = () => {
                document.getElementById('modal-confirm').removeEventListener('click', confirm);
                document.getElementById('modal-cancel').removeEventListener('click', cancel);
                input.removeEventListener('keydown', keyHandler);
            };

            const keyHandler = (e) => {
                if (e.key === 'Enter') confirm();
                if (e.key === 'Escape') cancel();
            };

            document.getElementById('modal-confirm').addEventListener('click', confirm);
            document.getElementById('modal-cancel').addEventListener('click', cancel);
            input.addEventListener('keydown', keyHandler);
        }

        // ===== Event Listeners =====
        document.getElementById('toggle-sidebar-btn').addEventListener('click', () => {
            document.getElementById('sidebar').classList.toggle('collapsed');
        });

        document.getElementById('new-file-sidebar-btn').addEventListener('click', createNewFile);

        document.getElementById('new-folder-btn').addEventListener('click', () => {
            showRenameModal('new-folder', 'New Folder', async (name) => {
                await createFolder(name);
                renderFileTree();
                updateStatus(`Created folder ${name}`);
            });
        });

        document.getElementById('close-comparison-btn').addEventListener('click', closeComparison);

        // Helper function to check if a file is binary
        function isBinaryFile(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const binaryExtensions = ['png', 'jpg', 'jpeg', 'gif', 'svg', 'webp', 'bmp', 'ico', 'pdf', 'zip', 'tar', 'gz', 'xlsx'];
            return binaryExtensions.includes(ext);
        }

        document.getElementById('file-upload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            console.log(file)
            if (!file) return;

            const reader = new FileReader();

            if (isBinaryFile(file.name)) {
                // Binary file - convert to base64
                reader.onload = async (event) => {
                    const dataUrl = event.target.result;

                    // Extract base64 content from data URL
                    // Data URL format: data:image/png;base64,iVBORw0KGgo...
                    const matches = dataUrl.match(/^data:[^;]+;base64,(.+)$/);

                    if (matches && matches[1]) {
                        const base64Content = matches[1];

                        // Create temporary file (not saved to IndexedDB yet)
                        const tempId = nextTempId--;
                        tempFiles.set(tempId, {
                            id: tempId,
                            name: file.name,
                            path: `/${file.name}`,
                            content: base64Content,
                            type: 'file',
                            parentId: null,
                            createdAt: new Date(),
                            updatedAt: new Date()
                        });

                        // Mark imported file as dirty (unsaved)
                        await openFile(tempId);
                        isDirty = true;
                        fileDirtyState.set(tempId, true);

                        updateStatus(`Imported binary file: ${file.name}`);
                    } else {
                        updateStatus('Failed to convert file to base64');
                    }
                };

                reader.readAsDataURL(file);
            } else {
                // Text file - read as text
                reader.onload = async (event) => {
                    const content = event.target.result;

                    // Create temporary file (not saved to IndexedDB yet)
                    const tempId = nextTempId--;
                    tempFiles.set(tempId, {
                        id: tempId,
                        name: file.name,
                        path: `/${file.name}`,
                        content: content,
                        type: 'file',
                        parentId: null,
                        createdAt: new Date(),
                        updatedAt: new Date()
                    });

                    await openFile(tempId);

                    // Mark imported file as dirty (unsaved)
                    isDirty = true;
                    fileDirtyState.set(tempId, true);

                    updateStatus(`Imported file: ${file.name}`);
                };

                reader.readAsText(file);
            }
        });

        // Listen for comparison format toggle (when allowed)
        document.getElementById('comparison-format-toggle').addEventListener('change', (e) => {
            if (!isComparing || !comparisonState || !comparisonState.canFormat) {
                e.target.checked = false;
                return;
            }
            const success = renderComparisonView(e.target.checked);
            if (e.target.checked && !success) {
                e.target.checked = false;
            }
        });

        document.getElementById('comparison-view-mode').addEventListener('change', (e) => {
            if (!isComparing || !comparisonState) {
                return;
            }
            comparisonViewMode = e.target.value === 'inline' ? 'inline' : 'side-by-side';
            const success = renderComparisonView(comparisonFormatEnabled);
            if (!success) {
                updateStatus('Error switching view mode');
            }
        });

        // Dropdown menu for case conversion
        const convertCaseBtn = document.getElementById('convert-case-btn');
        const convertCaseMenu = document.getElementById('convert-case-menu');

        convertCaseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            convertCaseMenu.classList.toggle('show');
        });

        // Dropdown menu for escape/unescape
        const escapeUnescapeBtn = document.getElementById('escape-unescape-btn');
        const escapeUnescapeMenu = document.getElementById('escape-unescape-menu');

        escapeUnescapeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            escapeUnescapeMenu.classList.toggle('show');
        });


        // Case conversion menu items
        document.getElementById('convert-pascal').addEventListener('click', () => {
            transformText(toPascalCase, 'PascalCase');
            convertCaseMenu.classList.remove('show');
        });

        document.getElementById('convert-camel').addEventListener('click', () => {
            transformText(toCamelCase, 'camelCase');
            convertCaseMenu.classList.remove('show');
        });

        document.getElementById('convert-snake').addEventListener('click', () => {
            transformText(toSnakeCase, 'snake_case');
            convertCaseMenu.classList.remove('show');
        });

        document.getElementById('convert-kebab').addEventListener('click', () => {
            transformText(toKebabCase, 'kebab-case');
            convertCaseMenu.classList.remove('show');
        });

        document.getElementById('convert-upper').addEventListener('click', () => {
            transformText(toUpperCase, 'UPPERCASE');
            convertCaseMenu.classList.remove('show');
        });

        document.getElementById('convert-lower').addEventListener('click', () => {
            transformText(toLowerCase, 'lowercase');
            convertCaseMenu.classList.remove('show');
        });

        // Escape/Unescape menu items
        document.getElementById('escape-json').addEventListener('click', () => {
            escapeToNewTab(escapeJson, 'JSON (escaped)');
            escapeUnescapeMenu.classList.remove('show');
        });

        document.getElementById('unescape-json').addEventListener('click', async () => {
            await unescapeToNewFile(unescapeJson, 'JSON (unescaped)', 'json');
            escapeUnescapeMenu.classList.remove('show');
        });

        document.getElementById('encode-url').addEventListener('click', () => {
            escapeToNewTab(encodeURL, 'URL (encoded)');
            escapeUnescapeMenu.classList.remove('show');
        });

        document.getElementById('decode-url').addEventListener('click', async () => {
            await unescapeToNewFile(decodeURL, 'URL (decoded)', 'url');
            escapeUnescapeMenu.classList.remove('show');
        });

        document.getElementById('encode-full-url').addEventListener('click', () => {
            escapeToNewTab(encodeFullURL, 'URL (full URI encoded)');
            escapeUnescapeMenu.classList.remove('show');
        });

        document.getElementById('decode-full-url').addEventListener('click', async () => {
            await unescapeToNewFile(decodeFullURL, 'URL (full URI decoded)', 'url');
            escapeUnescapeMenu.classList.remove('show');
        });

        document.getElementById('escape-html').addEventListener('click', () => {
            escapeToNewTab(escapeHTML, 'HTML (escaped)');
            escapeUnescapeMenu.classList.remove('show');
        });

        document.getElementById('unescape-html').addEventListener('click', async () => {
            await unescapeToNewFile(unescapeHTML, 'HTML (unescaped)', 'html');
            escapeUnescapeMenu.classList.remove('show');
        });

        // Dropdown menu for code formatting
        const formatBtn = document.getElementById('format-btn');
        const formatMenu = document.getElementById('format-menu');

        formatBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            formatMenu.classList.toggle('show');
        });

        // format menu items
        document.getElementById('format-code').addEventListener('click', async () => {
            await formatCode();
            formatMenu.classList.remove('show');
        });

        document.getElementById('minify-code').addEventListener('click', async () => {
            await minifyCode();
            formatMenu.classList.remove('show');
        });

        const base64Btn = document.getElementById('base64-btn');
        const base64Menu = document.getElementById('base64-menu');

        base64Btn.addEventListener('click', (e) => {
            e.stopPropagation();
            base64Menu.classList.toggle('show');
        });

        document.getElementById('encode-base64').addEventListener('click', () => {
            encodeBase64ToTab();
            base64Menu.classList.remove('show');
        });

        document.getElementById('decode-base64').addEventListener('click', () => {
            decodeBase64Preview();
            base64Menu.classList.remove('show');
        });

        // Dropdown menu for QR Code
        const qrcodeBtn = document.getElementById('qrcode-btn');
        const qrcodeMenu = document.getElementById('qrcode-menu');

        qrcodeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            qrcodeMenu.classList.toggle('show');
        });

        document.getElementById('generate-qrcode').addEventListener('click', () => {
            generateQRCode();
            qrcodeMenu.classList.remove('show');
        });

        document.getElementById('read-qrcode').addEventListener('click', () => {
            readQRCode();
            qrcodeMenu.classList.remove('show');
        });

        // Dropdown menu for JWT
        const jwtBtn = document.getElementById('jwt-btn');
        const jwtMenu = document.getElementById('jwt-menu');

        jwtBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            jwtMenu.classList.toggle('show');
        });

        document.getElementById('jwt-sign').addEventListener('click', () => {
            signJWT();
            jwtMenu.classList.remove('show');
        });

        document.getElementById('jwt-verify').addEventListener('click', () => {
            verifyJWT();
            jwtMenu.classList.remove('show');
        });

        document.getElementById('jwt-decode').addEventListener('click', () => {
            decodeJWTWithoutVerify();
            jwtMenu.classList.remove('show');
        });

        document.getElementById('jwt-settings').addEventListener('click', () => {
            openJWTSettings();
            jwtMenu.classList.remove('show');
        });

        // Dropdown menu for JWE
        const jweBtn = document.getElementById('jwe-btn');
        const jweMenu = document.getElementById('jwe-menu');

        jweBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            jweMenu.classList.toggle('show');
        });

        document.getElementById('jwe-encrypt').addEventListener('click', () => {
            encryptJWE();
            jweMenu.classList.remove('show');
        });

        document.getElementById('jwe-decrypt').addEventListener('click', () => {
            decryptJWE();
            jweMenu.classList.remove('show');
        });

        document.getElementById('jwe-settings').addEventListener('click', () => {
            openJWESettings();
            jweMenu.classList.remove('show');
        });

        // Generator Menu
        const generatorBtn = document.getElementById('generator-btn');
        const generatorMenu = document.getElementById('generator-menu');

        generatorBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            generatorMenu.classList.toggle('show');
        });

        let generatorMode = 'random'; // Track which generator mode: 'timestamp' or 'random'

        // Generator Modal Helper Functions
        function showGeneratorModal(mode) {
            generatorMode = mode;
            const modal = document.getElementById('generator-settings-modal');
            toggleGeneratorSections(mode);

            if (mode === 'random') {
                // Restore last selected regex preset and trigger change event
                const regexPreset = document.getElementById('regex-preset');
                if (regexPreset) {
                    regexPreset.value = generatorSettings.lastRegex;
                    regexPreset.dispatchEvent(new Event('change'));
                }
            }

            modal.style.display = 'flex';

            // Focus appropriate element for keyboard handling
            setTimeout(() => {
                if (mode === 'timestamp') {
                    const firstRadio = document.querySelector('input[name="timestamp-format"]:checked');
                    if (firstRadio) firstRadio.focus();
                } else if (mode === 'random') {
                    const regexPreset = document.getElementById('regex-preset');
                    if (regexPreset) regexPreset.focus();
                }
            }, 0);

            // Keyboard handler
            const keyHandler = async (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (generatorMode === 'timestamp') {
                        await generateTimestamp();
                    } else if (generatorMode === 'random') {
                        await generateRandomString();
                    }
                    hideGeneratorModal();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    hideGeneratorModal();
                }
            };

            // Attach listener to modal content
            const modalContent = modal.querySelector('.modal-content');
            modalContent.addEventListener('keydown', keyHandler);

            // Store cleanup function
            modal._cleanup = () => {
                modalContent.removeEventListener('keydown', keyHandler);
            };
        }

        function hideGeneratorModal() {
            const modal = document.getElementById('generator-settings-modal');
            modal.style.display = 'none';

            // Cleanup listeners
            if (modal._cleanup) {
                modal._cleanup();
                modal._cleanup = null;
            }
        }

        document.getElementById('generate-timestamp').addEventListener('click', () => {
            showGeneratorModal('timestamp');
            generatorMenu.classList.remove('show');
        });

        document.getElementById('generate-uuid').addEventListener('click', () => {
            generateUUID();
            generatorMenu.classList.remove('show');
        });

        document.getElementById('generate-random-string').addEventListener('click', () => {
            showGeneratorModal('random');
            generatorMenu.classList.remove('show');
        });

        // Generator Settings Modal
        const generatorSettingsModal = document.getElementById('generator-settings-modal');

        document.getElementById('generator-settings-cancel').addEventListener('click', () => {
            hideGeneratorModal();
        });

        document.getElementById('generator-settings-generate').addEventListener('click', async () => {
            if (generatorMode === 'timestamp') {
                await generateTimestamp();
            } else if (generatorMode === 'random') {
                await generateRandomString();
            }
            hideGeneratorModal();
        });

        // Format Type Modal
        document.getElementById('format-type-ok').addEventListener('click', () => {
            const modal = document.getElementById('format-type-modal');
            if (modal._resolve) {
                modal._resolve();
            }
        });

        document.getElementById('format-type-cancel').addEventListener('click', () => {
            const modal = document.getElementById('format-type-modal');
            if (modal._reject) {
                modal._reject();
            }
        });

        // Regex preset change handler
        document.getElementById('regex-preset').addEventListener('change', (e) => {
            const customSection = document.getElementById('custom-regex-section');
            const nameInput = document.getElementById('custom-regex-name');
            const patternInput = document.getElementById('custom-regex-pattern');
            const deleteBtn = document.getElementById('delete-custom-regex-btn');
            const selectedValue = e.target.value;

            // Check if it's a predefined preset
            const presets = ['alpha', 'numeric', 'alphanumeric', 'special'];
            if (presets.includes(selectedValue)) {
                customSection.style.display = 'none';
            }
            // Check if it's the "Custom Regex..." option for creating new
            else if (selectedValue === 'custom') {
                customSection.style.display = 'block';
                nameInput.value = '';
                patternInput.value = '';
                deleteBtn.style.display = 'none';
            }
            // Otherwise it's a custom regex ID
            else {
                const customRegex = generatorSettings.customRegexes.find(r => r.id === selectedValue);
                if (customRegex) {
                    customSection.style.display = 'block';
                    nameInput.value = customRegex.name;
                    patternInput.value = customRegex.pattern;
                    deleteBtn.style.display = 'block';
                }
            }
        });

        // Delete custom regex button handler
        document.getElementById('delete-custom-regex-btn').addEventListener('click', async () => {
            const select = document.getElementById('regex-preset');
            const selectedValue = select.value;

            // Only delete if a custom regex is selected (not a preset or 'custom')
            const presets = ['alpha', 'numeric', 'alphanumeric', 'special', 'custom'];
            if (!presets.includes(selectedValue)) {
                await deleteCustomRegex(selectedValue);
            }
        });

        // JWT Settings Modal
        const jwtSettingsModal = document.getElementById('jwt-settings-modal');

        function openJWTSettings() {
            updateJWTSettingsUI();
            jwtSettingsModal.style.display = 'flex';
        }

        document.getElementById('jwt-settings-cancel').addEventListener('click', () => {
            jwtSettingsModal.style.display = 'none';
        });

        document.getElementById('jwt-settings-save').addEventListener('click', async () => {
            // Save settings from UI
            jwtSettings.algorithm = document.getElementById('jwt-algorithm').value;
            jwtSettings.secretKey = document.getElementById('jwt-secret-key').value;
            jwtSettings.publicKeyPem = document.getElementById('jwt-public-key').value;
            jwtSettings.privateKeyPem = document.getElementById('jwt-private-key').value;
            jwtSettings.autoIat = document.getElementById('jwt-auto-iat').checked;
            jwtSettings.autoExp = document.getElementById('jwt-auto-exp').checked;
            jwtSettings.expDuration = parseInt(document.getElementById('jwt-exp-duration').value) || 1;
            jwtSettings.expUnit = document.getElementById('jwt-exp-unit').value;

            await saveJWTSettings(jwtSettings);
            jwtSettingsModal.style.display = 'none';
            updateStatus('JWT settings saved');
        });

        // Algorithm change handler
        document.getElementById('jwt-algorithm').addEventListener('change', (e) => {
            jwtSettings.algorithm = e.target.value;
            updateJWTSettingsUI();
        });

        // Auto Exp checkbox handler
        document.getElementById('jwt-auto-exp').addEventListener('change', (e) => {
            const expConfigSection = document.getElementById('exp-config-section');
            expConfigSection.style.display = e.target.checked ? '' : 'none';
        });

        // Generate key pair button
        document.getElementById('jwt-generate-keypair-btn').addEventListener('click', () => {
            generateKeyPair();
        });

        // Copy key buttons
        document.getElementById('jwt-copy-public-key-btn').addEventListener('click', () => {
            const publicKey = document.getElementById('jwt-public-key').value;
            if (publicKey) {
                copyToClipboard(publicKey, 'Public key');
            }
        });

        document.getElementById('jwt-copy-private-key-btn').addEventListener('click', () => {
            const privateKey = document.getElementById('jwt-private-key').value;
            if (privateKey) {
                copyToClipboard(privateKey, 'Private key');
            }
        });

        // Clear key buttons
        document.getElementById('jwt-clear-public-key-btn').addEventListener('click', () => {
            document.getElementById('jwt-public-key').value = '';
            jwtSettings.publicKeyPem = '';
        });

        document.getElementById('jwt-clear-private-key-btn').addEventListener('click', () => {
            document.getElementById('jwt-private-key').value = '';
            jwtSettings.privateKeyPem = '';
        });

        // Close JWT settings modal when clicking outside
        jwtSettingsModal.addEventListener('click', (e) => {
            if (e.target === jwtSettingsModal) {
                jwtSettingsModal.style.display = 'none';
            }
        });

        // JWE Settings Modal
        const jweSettingsModal = document.getElementById('jwe-settings-modal');

        function openJWESettings() {
            updateJWESettingsUI();
            jweSettingsModal.style.display = 'flex';
        }

        document.getElementById('jwe-settings-cancel').addEventListener('click', () => {
            jweSettingsModal.style.display = 'none';
        });

        document.getElementById('jwe-settings-save').addEventListener('click', async () => {
            // Save settings from UI
            jweSettings.algorithm = document.getElementById('jwe-algorithm').value;
            jweSettings.secretKey = document.getElementById('jwe-secret-key').value;
            jweSettings.publicKeyPem = document.getElementById('jwe-public-key').value;
            jweSettings.privateKeyPem = document.getElementById('jwe-private-key').value;
            jweSettings.autoIat = document.getElementById('jwe-auto-iat').checked;
            jweSettings.autoExp = document.getElementById('jwe-auto-exp').checked;
            jweSettings.expDuration = parseInt(document.getElementById('jwe-exp-duration').value) || 1;
            jweSettings.expUnit = document.getElementById('jwe-exp-unit').value;

            await saveJWESettings(jweSettings);
            jweSettingsModal.style.display = 'none';
            updateStatus('JWE settings saved');
        });

        document.getElementById('jwe-algorithm').addEventListener('change', (e) => {
            jweSettings.algorithm = e.target.value;
            updateJWESettingsUI();
        });

        document.getElementById('jwe-generate-keypair-btn').addEventListener('click', () => {
            generateJWEKeyPair();
        });

        // JWE Auto Exp checkbox handler
        document.getElementById('jwe-auto-exp').addEventListener('change', (e) => {
            const expConfigSection = document.getElementById('jwe-exp-config-section');
            expConfigSection.style.display = e.target.checked ? '' : 'none';
        });

        // Close JWE settings modal when clicking outside
        jweSettingsModal.addEventListener('click', (e) => {
            if (e.target === jweSettingsModal) {
                jweSettingsModal.style.display = 'none';
            }
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            convertCaseMenu.classList.remove('show');
            escapeUnescapeMenu.classList.remove('show');
            formatMenu.classList.remove('show');
            base64Menu.classList.remove('show');
            qrcodeMenu.classList.remove('show');
            jwtMenu.classList.remove('show');
            jweMenu.classList.remove('show');
            generatorMenu.classList.remove('show');
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Cmd+S or Ctrl+S for save
            if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                e.preventDefault();
                saveCurrentFile();
            }

            // Cmd+N or Ctrl+N for new file
            if ((e.metaKey || e.ctrlKey) && e.key === 'n') {
                e.preventDefault();
                createNewFile();
            }

            // Opt+Shift+F on macOS or Ctrl+Shift+F for format
            if ((isMac ? e.altKey : e.ctrlKey) && e.shiftKey && e.code === 'KeyF') {
                e.preventDefault();
                formatCode();
            }

            if (e.key === 'Tab') {
                const focusedView = (leftView && leftView.hasFocus) ? leftView
                    : (rightView && rightView.hasFocus) ? rightView
                    : (view && view.hasFocus) ? view
                    : null;
                if (focusedView) {
                    e.preventDefault();
                    const selection = focusedView.state.selection.main;
                    const indentUnit = '  ';
                    if (selection.empty) {
                        if (e.shiftKey) {
                            const from = Math.max(selection.from - indentUnit.length, 0);
                            const before = focusedView.state.doc.sliceString(from, selection.from);
                            if (before === indentUnit) {
                                focusedView.dispatch({
                                    changes: { from, to: selection.from, insert: '' },
                                    selection: EditorSelection.cursor(from)
                                });
                            }
                        } else {
                            focusedView.dispatch({
                                changes: { from: selection.from, to: selection.to, insert: indentUnit },
                                selection: EditorSelection.cursor(selection.from + indentUnit.length)
                            });
                        }
                    } else if (e.shiftKey) {
                        indentLess(focusedView);
                    } else {
                        indentMore(focusedView);
                    }
                }
            }
        });

        // ===== Initialize =====
        async function init() {
            await initDB();
            await initJWTSettings();
            await initJWESettings();
            await initGeneratorSettings();
            await initFormatSettings();
            await initAppSettings();
            await renderFileTree();
            const items = await getAllItems();
            const files = items.filter(item => item.type === 'file');
            let opened = false;
            if (appSettings.lastOpenedFileId) {
                const lastOpened = await getItem(appSettings.lastOpenedFileId);
                if (lastOpened && lastOpened.type === 'file') {
                    await openFile(lastOpened.id);
                    opened = true;
                } else {
                    appSettings.lastOpenedFileId = null;
                    await saveAppSettings(appSettings);
                }
            }
            let didOpenOrCreate = opened;
            if (!opened && files.length === 0) {
                await createNewFile();
                didOpenOrCreate = true;
            }
            initFileTreeDropZone();
            if (!didOpenOrCreate) {
                updateStatus('Ready');
            }

            // Attach context menu to editor container
            const editorContainer = document.getElementById('editor-container');
            editorContainer.addEventListener('contextmenu', showEditorContextMenu);

            // Warn before leaving page if there are unsaved changes
            window.addEventListener('beforeunload', (e) => {
                // Check if current file OR any other files have unsaved changes
                if (isDirty || Array.from(fileDirtyState.values()).some(i => i)) {
                    e.preventDefault();
                    e.returnValue = ''; // Required for Chrome
                    return ''; // Required for some browsers
                }
            });
        }

        init();
    </script>
</body>
</html>
